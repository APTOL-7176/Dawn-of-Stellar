#!/usr/bin/env python3
"""
ìë™ íŒŒí‹° êµ¬ì„± ì‹œìŠ¤í…œ - ë°¸ëŸ°ìŠ¤ ì¡íŒ íŒŒí‹° ìë™ ìƒì„±
"""

import random
from typing import List, Dict, Any, Optional
from game.character import Character, CharacterClassManager, CharacterTrait  # CharacterTrait ì¶”ê°€
from game.input_utils import KeyboardInput
from game import enhanced_items
from config import game_config

# ìƒ‰ìƒ ì •ì˜
RESET = '\033[0m'
BOLD = '\033[1m'
RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
BLUE = '\033[94m'
MAGENTA = '\033[95m'
CYAN = '\033[96m'
WHITE = '\033[97m'
BRIGHT_YELLOW = '\033[93m\033[1m'
BRIGHT_CYAN = '\033[96m\033[1m'
BRIGHT_WHITE = '\033[97m\033[1m'

class AutoPartyBuilder:
    """ìë™ íŒŒí‹° êµ¬ì„± ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.keyboard = KeyboardInput()
        self._used_names = set()
    
    # ì „ì²´ ì§ì—… ì •ì˜ (ê¸°ë³¸ 8ê°œ + í•´ê¸ˆ 19ê°œ)
    ALL_CLASSES = [
        # ê¸°ë³¸ 8ê°œ ì§ì—… (ì“°ê¸° ì‰¬ìš´ ì§ì—…ë“¤)
        "ì „ì‚¬", "ê¶ìˆ˜", "ì„±ê¸°ì‚¬", "ì•”í‘ê¸°ì‚¬", "ë°”ë“œ", "ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬",
        
        # í•´ê¸ˆ í•„ìš”í•œ 19ê°œ ì§ì—…
        "ì•„í¬ë©”ì´ì§€", "ë„ì ", "ëª½í¬", "ë„¤í¬ë¡œë§¨ì„œ", "ìš©ê¸°ì‚¬", "ì •ë ¹ìˆ ì‚¬", "ì•”ì‚´ì", 
        "ê¸°ê³„ê³µí•™ì", "ë¬´ë‹¹", "í•´ì ", "ì‚¬ë¬´ë¼ì´", "ë“œë£¨ì´ë“œ", "ì² í•™ì", "ì‹œê°„ìˆ ì‚¬", 
        "ì—°ê¸ˆìˆ ì‚¬", "ê¸°ì‚¬", "ì‹ ê´€", "ë§ˆê²€ì‚¬", "ì°¨ì›ìˆ ì‚¬"
    ]
    
    # ì—­í• ë³„ ë¶„ë¥˜ (Phase 1&2 ì§ì—… í¬í•¨) - í†µì¼ëœ ë¶„ë¥˜
    ROLE_CLASSES = {
        "íƒ±ì»¤": ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ì•”í‘ê¸°ì‚¬", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬", "ìš©ê¸°ì‚¬"],
        "ë”œëŸ¬": ["ê¶ìˆ˜", "ë„ì ", "ì•”ì‚´ì", "ê²€ì„±", "ì‚¬ë¬´ë¼ì´"],
        "ë§ˆë²•ì‚¬": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë§ˆê²€ì‚¬", "ê¸°ê³„ê³µí•™ì"],
        "ì„œí¬í„°": ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹", "ì² í•™ì"],
        "í•˜ì´ë¸Œë¦¬ë“œ": ["ëª½í¬", "í•´ì "]
    }
    
    # ì‹œë„ˆì§€ ì¡°í•© (ìƒˆë¡œìš´ ì§ì—… ì‹œë„ˆì§€ ì¶”ê°€)
    SYNERGY_COMBINATIONS = {
        "ì„±ê¸°ì‚¬ + ì‹ ê´€": {"bonus": "ì‹ ì„± ì‹œë„ˆì§€", "effect": "ì–¸ë°ë“œì—ê²Œ ì¶”ê°€ í”¼í•´"},
        "ì•”í‘ê¸°ì‚¬ + ë„¤í¬ë¡œë§¨ì„œ": {"bonus": "ì–´ë‘  ì‹œë„ˆì§€", "effect": "ìƒëª…ë ¥ í¡ìˆ˜ ì¦ê°€"},
        "ê¶ìˆ˜ + ì‚¬ë¬´ë¼ì´": {"bonus": "ì›ê±°ë¦¬ + ê·¼ê±°ë¦¬", "effect": "ì†ë„ ë³´ë„ˆìŠ¤"},
        "ë°”ë“œ + ì•„í¬ë©”ì´ì§€": {"bonus": "ë§ˆë²• ì¦í­", "effect": "ë§ˆë²• í”¼í•´ ì¦ê°€"},
        "ë“œë£¨ì´ë“œ + ì •ë ¹ìˆ ì‚¬": {"bonus": "ìì—° ì¡°í™”", "effect": "MP íšŒë³µ ì¦ê°€"},
        "ê¸°ê³„ê³µí•™ì + ì—°ê¸ˆìˆ ì‚¬": {"bonus": "ê³¼í•™ ì¡°í•©", "effect": "ì•„ì´í…œ íš¨ê³¼ ì¦ê°€"},
        
        # ğŸŒŸ Phase 1&2 ìƒˆë¡œìš´ ì‹œë„ˆì§€
        "ê²€ì„± + ê²€íˆ¬ì‚¬": {"bonus": "ê²€ìˆ  ëŒ€ê°€", "effect": "ê²€ê¸°/ì²˜ì¹˜ ìŠ¤íƒ íš¨ìœ¨ ì¦ê°€"},
        "ê´‘ì „ì‚¬ + ì•”í‘ê¸°ì‚¬": {"bonus": "í¡í˜ˆ ì „ì‚¬", "effect": "ìƒëª…ë ¥ í¡ìˆ˜ íš¨ê³¼ 2ë°°"},
        "ê¸°ì‚¬ + ì„±ê¸°ì‚¬": {"bonus": "ê¸°ì‚¬ë‹¨", "effect": "ë³´í˜¸ ë° ì¹˜ìœ  íš¨ê³¼ ì¦ê°€"},
        "ìš©ê¸°ì‚¬ + ì•„í¬ë©”ì´ì§€": {"bonus": "ì›ì†Œ ìœµí•©", "effect": "í™”ì—¼+ë²ˆê°œ ë³µí•© ê³µê²©"},
        "ê²€ì„± + ê´‘ì „ì‚¬": {"bonus": "ê²€ì˜ ê´‘ê¸°", "effect": "ìŠ¤íƒ ìƒì„± ì†ë„ ì¦ê°€"},
        "ê²€íˆ¬ì‚¬ + ê¸°ì‚¬": {"bonus": "íˆ¬ê¸°ì¥ ê¸°ì‚¬", "effect": "íŒ¨ë§ ì„±ê³µ ì‹œ ì˜ë¬´ ìŠ¤íƒ íšë“"}
    }
    
    # ì§ì—…ë³„ ê³ ìœ  ê¸°ë¯¹ ì •ë³´ (ìƒíƒœì°½ í‘œì‹œìš©)
    CLASS_MECHANICS = {
        "ê²€ì„±": {"type": "ìŠ¤íƒ", "display": "ê²€ê¸° ìŠ¤íƒ", "max": 2, "description": "BRV ê³µê²© ì‹œ íšë“, HPê³µê²©/ìŠ¤í‚¬ì— ì†Œëª¨í•˜ì—¬ ìœ„ë ¥ ì¦í­"},
        "ê²€íˆ¬ì‚¬": {"type": "ìŠ¤íƒ", "display": "ì²˜ì¹˜ ìŠ¤íƒ", "max": 99, "description": "ì  ì²˜ì¹˜ ì‹œ ê³µê²©ë ¥/MP/HP ì¦ê°€ (ì „íˆ¬ ë‚´ ë¬´í•œ ì¤‘ì²©)"},
        "ê´‘ì „ì‚¬": {"type": "ë³´í˜¸ë§‰", "display": "í”¼ì˜ ë³´í˜¸ë§‰", "max": 999999, "description": "HP ì†Œëª¨í•˜ì—¬ ìƒì„±, ë³´í˜¸ë§‰ ì†Œëª¨ ì‹œ í¡í˜ˆ íšŒë³µ"},
        "ê¸°ì‚¬": {"type": "ìŠ¤íƒ", "display": "ì˜ë¬´ ìŠ¤íƒ", "max": 5, "description": "ì•„êµ° ëŒ€ì‹  í”¼í•´ ì‹œ íšë“, 3ìŠ¤íƒ ì´ìƒ ì‹œ ì£½ìŒ íšŒí”¼"},
        "ì„±ê¸°ì‚¬": {"type": "í•„ë“œ", "display": "ì„±ì—­", "max": 3, "description": "ë²„í”„ ì•„êµ° í”¼í•´ ì‹œ ìƒì„±, ì„±ì—­ ìˆ˜ì— ë”°ë¥¸ ê°•í™”"},
        "ì•”í‘ê¸°ì‚¬": {"type": "í¡ìˆ˜", "display": "ì–´ë‘  í¡ìˆ˜", "max": 999999, "description": "í”¼í•´ í¡ìˆ˜í•˜ì—¬ ìŠ¤íƒí™” (ìµœëŒ€ HP 75%)"},
        "ìš©ê¸°ì‚¬": {"type": "í‘œì‹", "display": "ìš©ì˜ í‘œì‹", "max": 5, "description": "ë„ì•½ ê³µê²© ì‹œ ë¶€ì—¬, ì°©ì§€ ì‹œ í‘œì‹ë‹¹ ì¶”ê°€ í”¼í•´"},
        "ì•„í¬ë©”ì´ì§€": {"type": "ì›ì†Œ", "display": "ì›ì†Œ ìˆœí™˜", "max": 3, "description": "ë™ì¼ ì†ì„± 3íšŒ ì‚¬ìš© ì‹œ ê°•í™” ë§ˆë²• ìë™ ë°œë™"},
        "ì •ë ¹ìˆ ì‚¬": {"type": "ì†Œí™˜", "display": "ì •ë ¹", "max": 2, "description": "ìƒí™©ë³„ ì •ë ¹ ìë™ ì†Œí™˜ (ë¶ˆ/ë¬¼/ë°”ëŒ/ë•…)"},
        "ì‹œê°„ìˆ ì‚¬": {"type": "ì €ì¥", "display": "ì‹œê°„ ì €ì¥", "max": 1, "description": "ì•„êµ°/ì  ìƒíƒœë¥¼ ì‹œì ìœ¼ë¡œ ì €ì¥í•˜ì—¬ ë³µì›"},
        "ì°¨ì›ìˆ ì‚¬": {"type": "ìŠ¤íƒ", "display": "ì”ìƒ ìŠ¤íƒ", "max": 5, "description": "íšŒí”¼ ì„±ê³µ ì‹œ ì¶•ì , ì°¨ì›ì´ë™ ê³µê²©ì— ì‚¬ìš©"},
        "ë„¤í¬ë¡œë§¨ì„œ": {"type": "ì‹œì²´", "display": "ì‹œì²´ ìˆ˜ì§‘", "max": 10, "description": "ì£½ì€ ìë¥¼ ì‹œì²´ë¡œ ìˆ˜ì§‘, ì–¸ë°ë“œ ì†Œí™˜/í­ë°œì— ì‚¬ìš©"},
        "ì•”ì‚´ì": {"type": "ìŠ¤íƒ", "display": "ê·¸ë¦¼ì ìŠ¤íƒ", "max": 3, "description": "ì€ì‹  ì„±ê³µ ì‹œ ì¶•ì , ì•”ì‚´ ê³µê²© ìœ„ë ¥ ì¦í­"},
        "ê¶ìˆ˜": {"type": "ìŠ¤íƒ", "display": "ì¡°ì¤€ í¬ì¸íŠ¸", "max": 5, "description": "ìŠ¤í‚¬ ì‚¬ìš© ì‹œ ì¶•ì , ëª…ì¤‘ë¥ /ì¹˜ëª…íƒ€ìœ¨ ì¦ê°€"},
        "ê¸°ê³„ê³µí•™ì": {"type": "ì†Œí™˜", "display": "ê¸°ê³„ ìœ ë‹›", "max": 3, "description": "í¬íƒ‘/ë“œë¡  ì„¤ì¹˜, ìë™ ê¸°ëŠ¥ ë°œë™"},
        "ì² í•™ì": {"type": "ìŠ¤íƒ", "display": "ë¶„ì„ ìŠ¤íƒ", "max": 3, "description": "ì  ë¶„ì„í•˜ì—¬ ì ì‘í˜• ìŠ¤í‚¬ ê°•í™”"},
        "í•´ì ": {"type": "ìˆ˜ì§‘", "display": "ì•½íƒˆí’ˆ", "max": 99, "description": "ì  ì²˜ì¹˜ ì‹œ ìì›/ì•„ì´í…œ/ë²„í”„ ê°•íƒˆ"},
        "ì‚¬ë¬´ë¼ì´": {"type": "ê²Œì´ì§€", "display": "ì˜ì§€ ê²Œì´ì§€", "max": 100, "description": "íšŒí”¼/ë°˜ê²© ì„±ê³µ ì‹œ ì¦ê°€, ê°•ë ¥í•œ ê¸°ìˆ  ë°œë™"},
        "ë°”ë“œ": {"type": "ìŒê³„", "display": "ìŒê³„ ì§„í–‰", "max": 7, "description": "ë„ë ˆë¯¸íŒŒì†”ë¼ì‹œ ì§„í–‰, ì˜¥íƒ€ë¸Œ ì™„ì„± ì‹œ ê°•ë ¥ ë²„í”„"},
        "ë¬´ë‹¹": {"type": "ì „í™˜", "display": "ë””ë²„í”„ ì „í™˜", "max": 5, "description": "ë””ë²„í”„ë¥¼ ë²„í”„ë¡œ ì „í™˜í•˜ê±°ë‚˜ ë°˜ì‚¬"},
        "ë“œë£¨ì´ë“œ": {"type": "ë³€ì‹ ", "display": "ìì—° ê°ì‘", "max": 100, "description": "ê°ì‘ë„ ì¶•ì í•˜ì—¬ ì•¼ìˆ˜/ì‹ë¬¼ í˜•íƒœ ë³€ì‹ "},
        "ì‹ ê´€": {"type": "ìŠ¤íƒ", "display": "ì†ì£„ ìŠ¤íƒ", "max": 99, "description": "í”¼í•´ ë°›ì„ ë•Œ ì¶•ì , ì¹˜ìœ /ë°©ì–´ë§‰ì— ì‚¬ìš©"},
        "ëª½í¬": {"type": "ì½¤ë³´", "display": "ê¸° ì½¤ë³´", "max": 5, "description": "ì—°ì† ê³µê²© ì½¤ë³´, ê¸° ì¶•ì ìœ¼ë¡œ ê°•í™”"},
        "ë§ˆê²€ì‚¬": {"type": "ì†ì„±", "display": "ì›ì†Œ ë¶€ì—¬", "max": 4, "description": "ë¬´ê¸°ì— ì†ì„± ë¶€ì—¬, ì›ì†Œ ì¡°í•©ìœ¼ë¡œ ì—°ì‡„ ë°˜ì‘"}
    }
    
    # ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ì¶”ì²œì„ ìœ„í•œ ì§ˆë¬¸ í’€ (30ê°œ ì§ˆë¬¸)
    PARTY_QUESTIONS = [
        {
            "question": "ì–´ë–¤ ì „íˆ¬ ìŠ¤íƒ€ì¼ì„ ì„ í˜¸í•˜ì‹œë‚˜ìš”?",
            "answers": [
                {"text": "ì†ì „ì†ê²°! ë¹ ë¥´ê²Œ ëë‚´ê³  ì‹¶ì–´ìš”", "tags": ["ì†ë„", "ë”œëŸ¬", "í¬ë¦¬í‹°ì»¬", "ê³µê²©ì ", "ë¹ ë¦„"]},
                {"text": "ì•ˆì „í•˜ê²Œ ì²œì²œíˆ ì§„í–‰í•˜ê³  ì‹¶ì–´ìš”", "tags": ["íƒ±ì»¤", "ìƒì¡´", "ë°©ì–´", "ì•ˆì •", "ì‹ ì¤‘"]},
                {"text": "í™”ë ¤í•œ ë§ˆë²•ìœ¼ë¡œ ì‹¸ìš°ê³  ì‹¶ì–´ìš”", "tags": ["ë§ˆë²•", "ì›ì†Œ", "AOE", "í™”ë ¤", "ë§ˆë²•ì‚¬"]},
                {"text": "ì „ëµì ì´ê³  ë³µì¡í•œ ì „íˆ¬ë¥¼ ì¢‹ì•„í•´ìš”", "tags": ["í•˜ì´ë¸Œë¦¬ë“œ", "ì‹œë„ˆì§€", "ë³µí•©", "ì „ëµ", "ê¹Šì´"]}
            ]
        },
        {
            "question": "íŒŒí‹°ì—ì„œ ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•˜ëŠ” ê²ƒì€?",
            "answers": [
                {"text": "ë†’ì€ ë°ë¯¸ì§€ë¡œ ì ì„ ë¹ ë¥´ê²Œ ì²˜ì¹˜", "tags": ["ë”œëŸ¬", "ê³µê²©", "DPS", "í­ë”œ", "ì²˜ì¹˜"]},
                {"text": "ì•ˆì •ì ì¸ ìƒì¡´ê³¼ íšŒë³µ", "tags": ["ì„œí¬í„°", "íë§", "ìƒì¡´", "íšŒë³µ", "ì•ˆì •"]},
                {"text": "ë‹¤ì–‘í•œ ìƒí™©ì— ëŒ€ì‘í•  ìˆ˜ ìˆëŠ” ìœ ì—°ì„±", "tags": ["í•˜ì´ë¸Œë¦¬ë“œ", "ìœ í‹¸", "ì ì‘", "ìœ ì—°", "ëŒ€ì‘"]},
                {"text": "ë…íŠ¹í•˜ê³  ì¬ë¯¸ìˆëŠ” ê¸°ë¯¹", "tags": ["íŠ¹ìˆ˜", "ìœ ë‹ˆí¬", "ì‹¤í—˜", "ê¸°ë¯¹", "ì°½ì˜"]}
            ]
        },
        {
            "question": "ì ê³¼ ë§ˆì£¼í–ˆì„ ë•Œ ì²« ë²ˆì§¸ í–‰ë™ì€?",
            "answers": [
                {"text": "ì¼ë‹¨ ê³µê²©! ì„ ì œ íƒ€ê²©ì´ ìµœê³ ", "tags": ["ê³µê²©", "ì„ ì œ", "ì–´ê·¸ë¡œ", "ì ê·¹", "ê³µê²©ì "]},
                {"text": "ë°©ì–´ íƒœì„¸ë¥¼ ê°–ì¶”ê³  ì‹ ì¤‘í•˜ê²Œ", "tags": ["ë°©ì–´", "íƒ±í‚¹", "ì‹ ì¤‘", "ë³´í˜¸", "ìˆ˜ë¹„"]},
                {"text": "ì ì˜ ì•½ì ì„ íŒŒì•…í•˜ê³  ë¶„ì„", "tags": ["ë¶„ì„", "ì „ëµ", "ì§€ëŠ¥", "ê´€ì°°", "ê³„íš"]},
                {"text": "ë™ë£Œë“¤ì„ ì§€ì›í•˜ê³  ë²„í”„", "tags": ["ì„œí¬íŠ¸", "íŒ€í”Œë ˆì´", "í˜‘ë ¥", "ì§€ì›", "ë²„í”„"]}
            ]
        },
        {
            "question": "ìœ„í—˜í•œ ìƒí™©ì—ì„œ ì–´ë–»ê²Œ ëŒ€ì²˜í•˜ë‚˜ìš”?",
            "answers": [
                {"text": "ë” ê°•í•˜ê²Œ ê³µê²©í•´ì„œ ëŒíŒŒ!", "tags": ["ê³µê²©ì ", "ëŒíŒŒ", "ê°•í•¨", "ìš©ê¸°", "ì ê·¹"]},
                {"text": "ë°©ì–´í•˜ë©´ì„œ ê¸°íšŒë¥¼ ê¸°ë‹¤ë ¤ìš”", "tags": ["ë°©ì–´", "ì¸ë‚´", "ê¸°ë‹¤ë¦¼", "ì‹ ì¤‘", "ìˆ˜ë¹„"]},
                {"text": "ê¸°ë°œí•œ ë°©ë²•ìœ¼ë¡œ í•´ê²°í•´ìš”", "tags": ["ì°½ì˜", "ê¸°ë°œ", "ë…íŠ¹", "ì‹¤í—˜", "ìœ ì—°"]},
                {"text": "íŒ€ì›ë“¤ê³¼ í˜‘ë ¥í•´ì„œ ê·¹ë³µí•´ìš”", "tags": ["í˜‘ë ¥", "íŒ€ì›Œí¬", "ì§€ì›", "ì¡°í™”", "í•¨ê»˜"]}
            ]
        },
        {
            "question": "ì„ í˜¸í•˜ëŠ” ìì› ê´€ë¦¬ ë°©ì‹ì€?",
            "answers": [
                {"text": "HPë¥¼ ì†Œëª¨í•´ì„œë¼ë„ ê°•ë ¥í•œ ê³µê²©!", "tags": ["HPì†Œëª¨", "ìœ„í—˜", "ê³µê²©ì ", "ë¦¬ìŠ¤í¬", "ê°•ë ¥í•¨"]},
                {"text": "MPë¥¼ ì•„ê»´ì„œ ì¤‘ìš”í•  ë•Œ ì‚¬ìš©", "tags": ["MPê´€ë¦¬", "ì ˆì•½", "ì‹ ì¤‘", "ê³„íš", "íš¨ìœ¨"]},
                {"text": "íŠ¹ìˆ˜ ìì›(ìŠ¤íƒ, ê²Œì´ì§€)ì„ í™œìš©", "tags": ["ìŠ¤íƒ", "ê²Œì´ì§€", "íŠ¹ìˆ˜", "ê´€ë¦¬", "ì „ëµ"]},
                {"text": "ìì›ë³´ë‹¤ëŠ” ê¸°ë³¸ ê³µê²© ìœ„ì£¼", "tags": ["ê¸°ë³¸ê³µê²©", "ë‹¨ìˆœ", "ì§ê´€", "ì•ˆì •", "ê¸°ë³¸"]}
            ]
        },
        {
            "question": "ì–´ë–¤ ì—­í• ì„ ë§¡ê³  ì‹¶ë‚˜ìš”?",
            "answers": [
                {"text": "ìµœì „ì„ ì—ì„œ ì ì„ ë§‰ëŠ” ë°©íŒ¨", "tags": ["íƒ±ì»¤", "ë°©ì–´", "ë³´í˜¸", "ìµœì „ì„ ", "ìˆ˜í˜¸"]},
                {"text": "ê°•ë ¥í•œ ê³µê²©ìœ¼ë¡œ ì ì„ ì“°ëŸ¬ëœ¨ë¦¬ëŠ” ê²€", "tags": ["ë”œëŸ¬", "ê³µê²©", "ì²˜ì¹˜", "ê²€", "ê°•ë ¥í•¨"]},
                {"text": "ë§ˆë²•ìœ¼ë¡œ ì „ì¥ì„ ì§€ë°°í•˜ëŠ” í˜„ì", "tags": ["ë§ˆë²•ì‚¬", "ì§€ë°°", "í˜„ì", "ë§ˆë²•", "ì§€ëŠ¥"]},
                {"text": "ë™ë£Œë¥¼ ë•ëŠ” ë“ ë“ í•œ ì§€ì›êµ°", "tags": ["ì„œí¬í„°", "ì§€ì›", "ë„ì›€", "ë“ ë“ í•¨", "í˜‘ë ¥"]}
            ]
        },
        {
            "question": "ê°€ì¥ ë§¤ë ¥ì ì¸ ì „íˆ¬ ê¸°ë¯¹ì€?",
            "answers": [
                {"text": "ìŠ¤íƒì„ ìŒ“ì•„ì„œ í­ë°œì ì¸ ì¼ê²©!", "tags": ["ìŠ¤íƒ", "í­ë°œ", "ì¼ê²©", "ì¶•ì ", "ê°•ë ¥í•¨"]},
                {"text": "íšŒí”¼ì™€ ë°˜ê²©ì˜ ì™„ë²½í•œ íƒ€ì´ë°", "tags": ["íšŒí”¼", "ë°˜ê²©", "íƒ€ì´ë°", "ì •ë°€", "ê¸°ìˆ "]},
                {"text": "ì›ì†Œë¥¼ ì¡°í•©í•œ í™”ë ¤í•œ ë§ˆë²•", "tags": ["ì›ì†Œ", "ì¡°í•©", "í™”ë ¤", "ë§ˆë²•", "ë‹¤ì–‘í•¨"]},
                {"text": "ë™ë£Œì™€ì˜ ì™„ë²½í•œ ì—°ê³„ í”Œë ˆì´", "tags": ["ì—°ê³„", "í˜‘ë ¥", "ì™„ë²½", "ì‹œë„ˆì§€", "íŒ€ì›Œí¬"]}
            ]
        },
        {
            "question": "ì „íˆ¬ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ëŠ¥ë ¥ì¹˜ëŠ”?",
            "answers": [
                {"text": "ì••ë„ì ì¸ ê³µê²©ë ¥", "tags": ["ê³µê²©ë ¥", "ì••ë„ì ", "ê°•í•¨", "í­ë”œ", "ë°ë¯¸ì§€"]},
                {"text": "íŠ¼íŠ¼í•œ ë°©ì–´ë ¥ê³¼ ì²´ë ¥", "tags": ["ë°©ì–´ë ¥", "ì²´ë ¥", "íŠ¼íŠ¼í•¨", "ìƒì¡´", "ì•ˆì •"]},
                {"text": "ë¹ ë¥¸ ì†ë„ì™€ ë¯¼ì²©ì„±", "tags": ["ì†ë„", "ë¯¼ì²©", "ë¹ ë¦„", "ê¸°ë™ë ¥", "ì„ ì œ"]},
                {"text": "ë†’ì€ ë§ˆë²•ë ¥ê³¼ ì§€ëŠ¥", "tags": ["ë§ˆë²•ë ¥", "ì§€ëŠ¥", "ë§ˆë²•", "í˜„ëª…í•¨", "ì „ëµ"]}
            ]
        },
        {
            "question": "ê²Œì„ì—ì„œ ê°€ì¥ ì§œë¦¿í•œ ìˆœê°„ì€?",
            "answers": [
                {"text": "í¬ë¦¬í‹°ì»¬ì´ í„°ì ¸ì„œ ì—„ì²­ë‚œ ë°ë¯¸ì§€!", "tags": ["í¬ë¦¬í‹°ì»¬", "í­ë”œ", "RNG", "ìš´", "í„°ì§"]},
                {"text": "ì ˆì²´ì ˆëª…ì˜ ìˆœê°„ì—ì„œ ì—­ì „!", "tags": ["ì—­ì „", "ìŠ¤ë¦´", "ê·¹í•œ", "ë“œë¼ë§ˆ", "ê¸´ì¥"]},
                {"text": "ì™„ë²½í•œ ì½¤ë³´ê°€ ë“¤ì–´ê°”ì„ ë•Œ", "tags": ["ì½¤ë³´", "ì—°ê³„", "ì •ë°€", "ì™„ë²½", "ê¸°ìˆ "]},
                {"text": "íŒ€ì›ë“¤ê³¼ ì™„ë²½í•œ í˜¸í¡ìœ¼ë¡œ ìŠ¹ë¦¬", "tags": ["íŒ€ì›Œí¬", "í˜‘ë ¥", "ì¡°í™”", "ì‹œë„ˆì§€", "ë‹¨ê²°"]}
            ]
        },
        {
            "question": "ì ì—ê²Œ ìƒíƒœì´ìƒì„ ê±°ëŠ” ê²ƒì— ëŒ€í•´?",
            "answers": [
                {"text": "ë…, í™”ìƒ ë“±ìœ¼ë¡œ ì„œì„œíˆ ê´´ë¡­íˆê¸°", "tags": ["ë…", "ì§€ì†í”¼í•´", "ì¸ë‚´", "ì„œì„œíˆ", "ê´´ë¡­í˜"]},
                {"text": "ì¹¨ë¬µ, ë§ˆë¹„ë¡œ í–‰ë™ì„ ë´‰ì‡„í•˜ê¸°", "tags": ["ì¹¨ë¬µ", "ë§ˆë¹„", "ë´‰ì‡„", "ë°©í•´", "ì œì–´"]},
                {"text": "ë²„í”„ë¡œ ì•„êµ°ì„ ê°•í™”í•˜ëŠ” ê²Œ ì¢‹ì•„", "tags": ["ë²„í”„", "ê°•í™”", "ì§€ì›", "ì•„êµ°", "ë„ì›€"]},
                {"text": "ìƒíƒœì´ìƒë³´ë‹¤ëŠ” ì§ì ‘ ê³µê²©!", "tags": ["ì§ì ‘ê³µê²©", "ë‹¨ìˆœ", "ê°•ë ¥í•¨", "ì¦‰ì‹œ", "ëª…í™•"]}
            ]
        },
        {
            "question": "íŒŒí‹°ì›ì´ ìœ„í—˜í•  ë•Œ ë‹¹ì‹ ì˜ ì„ íƒì€?",
            "answers": [
                {"text": "ëª¸ì„ ë˜ì ¸ì„œ ëŒ€ì‹  ë§ì•„ì£¼ê¸°", "tags": ["í¬ìƒ", "ë³´í˜¸", "íƒ±í‚¹", "ìš©ê¸°", "ìˆ˜í˜¸"]},
                {"text": "ì¦‰ì‹œ ì¹˜ìœ í•´ì„œ íšŒë³µì‹œí‚¤ê¸°", "tags": ["ì¹˜ìœ ", "íšŒë³µ", "ì„œí¬íŠ¸", "ë„ì›€", "ì¼€ì–´"]},
                {"text": "ì ì„ ë” ë¹¨ë¦¬ ì²˜ì¹˜í•´ì„œ í•´ê²°", "tags": ["ê³µê²©", "ì²˜ì¹˜", "ë¹ ë¦„", "ê³µê²©ì ", "í•´ê²°"]},
                {"text": "ì „ëµì ìœ¼ë¡œ ìœ„ì¹˜ë¥¼ ë°”ê¾¸ê¸°", "tags": ["ì „ëµ", "ìœ„ì¹˜", "ì´ë™", "ì§€ëŠ¥", "ê³„íš"]}
            ]
        },
        {
            "question": "ì„ í˜¸í•˜ëŠ” ë¬´ê¸° íƒ€ì…ì€?",
            "answers": [
                {"text": "ê²€ì´ë‚˜ ë„ë¼ ê°™ì€ ê·¼ì ‘ ë¬´ê¸°", "tags": ["ê·¼ì ‘", "ê²€", "ë¬¼ë¦¬", "ì§ì ‘", "ê°•í•¨"]},
                {"text": "í™œì´ë‚˜ ì´ ê°™ì€ ì›ê±°ë¦¬ ë¬´ê¸°", "tags": ["ì›ê±°ë¦¬", "í™œ", "ì •ë°€", "ì•ˆì „", "ê±°ë¦¬"]},
                {"text": "ì§€íŒ¡ì´ë‚˜ ì˜¤ë¸Œ ê°™ì€ ë§ˆë²• ë„êµ¬", "tags": ["ë§ˆë²•ë„êµ¬", "ì§€íŒ¡ì´", "ë§ˆë²•", "ì‹ ë¹„", "ì§€ëŠ¥"]},
                {"text": "ë°©íŒ¨ë‚˜ ë³´í˜¸êµ¬ ê°™ì€ ë°©ì–´êµ¬", "tags": ["ë°©íŒ¨", "ë°©ì–´", "ë³´í˜¸", "ì•ˆì „", "ìˆ˜ë¹„"]}
            ]
        },
        {
            "question": "ì „íˆ¬ í›„ ê°€ì¥ ë¨¼ì € í•˜ê³  ì‹¶ì€ ì¼ì€?",
            "answers": [
                {"text": "ì „ë¦¬í’ˆì„ ìˆ˜ì§‘í•˜ê³  ì •ë¦¬í•˜ê¸°", "tags": ["ìˆ˜ì§‘", "ì •ë¦¬", "ì „ë¦¬í’ˆ", "íš¨ìœ¨", "ê´€ë¦¬"]},
                {"text": "ë¶€ìƒì„ ì¹˜ë£Œí•˜ê³  íœ´ì‹í•˜ê¸°", "tags": ["ì¹˜ë£Œ", "íœ´ì‹", "íšŒë³µ", "ì•ˆì •", "ì¼€ì–´"]},
                {"text": "ë‹¤ìŒ ì „íˆ¬ë¥¼ ì¤€ë¹„í•˜ê³  ì „ëµ ì„¸ìš°ê¸°", "tags": ["ì¤€ë¹„", "ì „ëµ", "ê³„íš", "ë¯¸ë˜", "ì§€ëŠ¥"]},
                {"text": "ë™ë£Œë“¤ê³¼ ì „íˆ¬ë¥¼ ë˜ëŒì•„ë³´ê¸°", "tags": ["íšŒê³ ", "ë™ë£Œ", "ì†Œí†µ", "í•™ìŠµ", "íŒ€ì›Œí¬"]}
            ]
        },
        {
            "question": "ì–´ë–¤ í™˜ê²½ì—ì„œ ì‹¸ìš°ê³  ì‹¶ë‚˜ìš”?",
            "answers": [
                {"text": "ë„“ì€ í‰ì•¼ì—ì„œ ììœ ë¡­ê²Œ", "tags": ["ë„“ìŒ", "ììœ ", "ê°œë°©", "ê¸°ë™ì„±", "í™œë™"]},
                {"text": "ì¢ì€ í†µë¡œì—ì„œ ì „ëµì ìœ¼ë¡œ", "tags": ["ì¢ìŒ", "ì „ëµ", "ì œí•œ", "ì§‘ì¤‘", "ê³„íš"]},
                {"text": "ë§ˆë²•ì´ ê°•í™”ë˜ëŠ” ì‹ ë¹„í•œ ê³³", "tags": ["ë§ˆë²•ê°•í™”", "ì‹ ë¹„", "íŠ¹ë³„", "ë§ˆë²•", "í™˜ê²½"]},
                {"text": "ì–´ë””ë“  ìƒê´€ì—†ì–´, ì ì‘í•  ìˆ˜ ìˆì–´", "tags": ["ì ì‘", "ìœ ì—°", "ë²”ìš©", "ì•ˆì •", "ê· í˜•"]}
            ]
        },
        {
            "question": "ê°€ì¥ ì‹«ì–´í•˜ëŠ” ì ì˜ ìœ í˜•ì€?",
            "answers": [
                {"text": "ì—„ì²­ë‚˜ê²Œ ë‹¨ë‹¨í•œ ì ", "tags": ["ë‹¨ë‹¨í•¨", "ë°©ì–´", "ì¸ë‚´", "ì§€ì†", "ëˆê¸°"]},
                {"text": "ë„ˆë¬´ ë¹ ë¥´ê³  íšŒí”¼í•˜ëŠ” ì ", "tags": ["ë¹ ë¦„", "íšŒí”¼", "ë¯¼ì²©", "ì¶”ì ", "ì†ë„"]},
                {"text": "ë§ˆë²•ìœ¼ë¡œ ë°©í•´í•˜ëŠ” ì ", "tags": ["ë§ˆë²•ë°©í•´", "ì œì–´", "ëŒ€ì‘", "í•´ì œ", "ììœ "]},
                {"text": "ë¬´ë¦¬ë¥¼ ì§€ì–´ ëª°ë ¤ì˜¤ëŠ” ì ", "tags": ["ë¬´ë¦¬", "ë‹¤ìˆ˜", "AOE", "ê´‘ì—­", "íš¨ìœ¨"]}
            ]
        },
        {
            "question": "ì´ìƒì ì¸ ì „íˆ¬ ì‹œê°„ì€?",
            "answers": [
                {"text": "1-2í„´ ë§Œì— ëë‚´ëŠ” ì´ˆìŠ¤í”¼ë“œ", "tags": ["ì´ˆìŠ¤í”¼ë“œ", "ë¹ ë¦„", "í­ë”œ", "íš¨ìœ¨", "ì¦‰ì‹œ"]},
                {"text": "5-10í„´ ì •ë„ì˜ ì ë‹¹í•œ ê¸¸ì´", "tags": ["ì ë‹¹í•¨", "ê· í˜•", "ì•ˆì •", "ì—¬ìœ ", "ê³„íš"]},
                {"text": "ê¸¸ê³  ì¹˜ì—´í•œ ìŠ¹ë¶€", "tags": ["ê¸¸ê²Œ", "ì¹˜ì—´", "ì¸ë‚´", "ì „ëµ", "ê¹Šì´"]},
                {"text": "ìƒí™©ì— ë”°ë¼ ìœ ì—°í•˜ê²Œ", "tags": ["ìœ ì—°", "ìƒí™©ëŒ€ì‘", "ì ì‘", "ë³€í™”", "ê· í˜•"]}
            ]
        },
        {
            "question": "íŒ€ í”Œë ˆì´ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€?",
            "answers": [
                {"text": "ê°ìì˜ ì—­í• ì„ ì™„ë²½í•˜ê²Œ ìˆ˜í–‰", "tags": ["ì—­í• ìˆ˜í–‰", "ì™„ë²½", "ì „ë¬¸ì„±", "ì§‘ì¤‘", "ìˆ™ë ¨"]},
                {"text": "ì„œë¡œë¥¼ ë³´ì™„í•˜ë©° í˜‘ë ¥", "tags": ["ë³´ì™„", "í˜‘ë ¥", "ì‹œë„ˆì§€", "ë„ì›€", "ì¡°í™”"]},
                {"text": "ë¦¬ë”ì˜ ì§€ì‹œì— ë”°ë¼ í–‰ë™", "tags": ["ë¦¬ë”ì‹­", "ì§€ì‹œ", "ì¡°ì§", "ì²´ê³„", "í†µì œ"]},
                {"text": "ììœ ë¡­ê²Œ ê°ì íŒë‹¨í•´ì„œ í–‰ë™", "tags": ["ììœ ", "íŒë‹¨", "ë…ë¦½", "ì°½ì˜", "ìœ ì—°"]}
            ]
        },
        {
            "question": "ìºë¦­í„° ì„±ì¥ì—ì„œ ì¤‘ìš”í•œ ê²ƒì€?",
            "answers": [
                {"text": "ê°•ë ¥í•œ ê³µê²© ìŠ¤í‚¬ ìŠµë“", "tags": ["ê³µê²©ìŠ¤í‚¬", "ê°•ë ¥í•¨", "ë”œëŸ¬", "ìœ„ë ¥", "íŒŒê´´"]},
                {"text": "ìƒì¡´ì„ ìœ„í•œ ë°©ì–´ ëŠ¥ë ¥", "tags": ["ë°©ì–´ëŠ¥ë ¥", "ìƒì¡´", "ì•ˆì •", "ë²„í‹°ê¸°", "ì§€êµ¬ë ¥"]},
                {"text": "ë‹¤ì–‘í•œ ìœ í‹¸ë¦¬í‹° ìŠ¤í‚¬", "tags": ["ìœ í‹¸ë¦¬í‹°", "ë‹¤ì–‘í•¨", "ìœ ì—°", "ë„êµ¬", "í¸ì˜"]},
                {"text": "íŠ¹ë³„í•˜ê³  ë…íŠ¹í•œ ëŠ¥ë ¥", "tags": ["íŠ¹ë³„í•¨", "ë…íŠ¹í•¨", "ìœ ë‹ˆí¬", "ê°œì„±", "íŠ¹ìƒ‰"]}
            ]
        },
        {
            "question": "ê²Œì„ì—ì„œ ê°€ì¥ ì¢‹ì•„í•˜ëŠ” ìˆœê°„ì€?",
            "answers": [
                {"text": "ìƒˆë¡œìš´ ìŠ¤í‚¬ì„ ë°°ì› ì„ ë•Œ", "tags": ["ìŠ¤í‚¬ìŠµë“", "ì„±ì¥", "ìƒˆë¡œì›€", "ë°œì „", "í•™ìŠµ"]},
                {"text": "ì–´ë ¤ìš´ ì ì„ ë¬¼ë¦¬ì³¤ì„ ë•Œ", "tags": ["ìŠ¹ë¦¬", "ë„ì „", "ì„±ì·¨", "ê·¹ë³µ", "ì„±ê³µ"]},
                {"text": "ë™ë£Œì™€ ì™„ë²½í•œ ì—°ê³„ë¥¼ í–ˆì„ ë•Œ", "tags": ["ì—°ê³„", "íŒ€ì›Œí¬", "ì™„ë²½", "í˜‘ë ¥", "ì¡°í™”"]},
                {"text": "ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì—ì„œ ê¸°ì§€ë¥¼ ë°œíœ˜í–ˆì„ ë•Œ", "tags": ["ê¸°ì§€", "ì°½ì˜", "ìˆœë°œë ¥", "ë†€ë¼ì›€", "ë…ì°½"]}
            ]
        },
        {
            "question": "ë‹¹ì‹ ì˜ í”Œë ˆì´ ì² í•™ì€?",
            "answers": [
                {"text": "ê°•í•œ ìê°€ ì‚´ì•„ë‚¨ëŠ”ë‹¤", "tags": ["ê°•í•¨", "ìƒì¡´", "ê²½ìŸ", "ì‹¤ë ¥", "ìš°ìŠ¹"]},
                {"text": "ëª¨ë‘ê°€ í•¨ê»˜ ì„±ì¥í•œë‹¤", "tags": ["ì„±ì¥", "í•¨ê»˜", "ê³µë™ì²´", "í˜‘ë ¥", "ë°œì „"]},
                {"text": "ì¬ë¯¸ìˆìœ¼ë©´ ê·¸ê²ƒìœ¼ë¡œ ì¶©ë¶„í•˜ë‹¤", "tags": ["ì¬ë¯¸", "ì¦ê±°ì›€", "ì—”í„°í…Œì¸", "í–‰ë³µ", "ë§Œì¡±"]},
                {"text": "ì™„ë²½ì„ ì¶”êµ¬í•œë‹¤", "tags": ["ì™„ë²½", "ì •ë°€", "ì™„ì„±", "í’ˆì§ˆ", "ìµœê³ "]}
            ]
        },
        {
            "question": "ë³´ìŠ¤ì „ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ì „ëµì€?",
            "answers": [
                {"text": "ê°•ë ¥í•œ ì¼ê²©ìœ¼ë¡œ ë¹ ë¥´ê²Œ ëë‚´ê¸°", "tags": ["ì¼ê²©", "ë¹ ë¦„", "í­ë”œ", "ê³µê²©ì ", "ê²°ì •ì "]},
                {"text": "ì•ˆì „í•˜ê²Œ íŒ¨í„´ì„ íŒŒì•…í•˜ë©° ê³µëµ", "tags": ["íŒ¨í„´", "ì•ˆì „", "ë¶„ì„", "ì‹ ì¤‘", "í•™ìŠµ"]},
                {"text": "íŒ€ì›ë“¤ê³¼ ì—­í•  ë¶„ë‹´í•´ì„œ í˜‘ë ¥", "tags": ["í˜‘ë ¥", "ì—­í• ë¶„ë‹´", "íŒ€ì›Œí¬", "ì¡°ì§", "ì‹œë„ˆì§€"]},
                {"text": "ì°½ì˜ì ì¸ ë°©ë²•ìœ¼ë¡œ ì•½ì  ê³µëµ", "tags": ["ì°½ì˜", "ì•½ì ", "ê¸°ë°œ", "ì „ëµ", "ë…íŠ¹"]}
            ]
        },
        {
            "question": "ë˜ì „ íƒí—˜ì—ì„œ ê°€ì¥ í¥ë¯¸ë¡œìš´ ìš”ì†ŒëŠ”?",
            "answers": [
                {"text": "ìˆ¨ê²¨ì§„ ë³´ë¬¼ê³¼ ë¹„ë°€ ë°©", "tags": ["ë³´ë¬¼", "ë¹„ë°€", "íƒí—˜", "ë°œê²¬", "ìˆ˜ì§‘"]},
                {"text": "ë‹¤ì–‘í•œ ëª¬ìŠ¤í„°ì™€ì˜ ì „íˆ¬", "tags": ["ëª¬ìŠ¤í„°", "ì „íˆ¬", "ë‹¤ì–‘í•¨", "ë„ì „", "ì•¡ì…˜"]},
                {"text": "í¼ì¦ê³¼ í•¨ì • í•´ê²°", "tags": ["í¼ì¦", "í•¨ì •", "ì§€ëŠ¥", "í•´ê²°", "ì‚¬ê³ "]},
                {"text": "ë™ë£Œë“¤ê³¼ì˜ ëª¨í—˜ ì´ì•¼ê¸°", "tags": ["ëª¨í—˜", "ì´ì•¼ê¸°", "ë™ë£Œ", "ì¶”ì–µ", "ì—¬ì •"]}
            ]
        },
        {
            "question": "ì ì˜ ì•½ì ì„ ë°œê²¬í–ˆì„ ë•Œ ì–´ë–»ê²Œ í•˜ë‚˜ìš”?",
            "answers": [
                {"text": "ì¦‰ì‹œ ì•½ì ì„ ì§‘ì¤‘ ê³µê²©", "tags": ["ì§‘ì¤‘ê³µê²©", "ì•½ì ", "ì¦‰ì‹œ", "íš¨ìœ¨", "íƒ€ê²ŸíŒ…"]},
                {"text": "íŒ€ì›ë“¤ì—ê²Œ ì•Œë ¤ì„œ í•¨ê»˜ ê³µëµ", "tags": ["ì •ë³´ê³µìœ ", "íŒ€ì›Œí¬", "ì†Œí†µ", "í˜‘ë ¥", "ì¡°ì§"]},
                {"text": "ì•½ì  ê³µê²©ìš© ìŠ¤í‚¬ì„ ì¤€ë¹„", "tags": ["ì¤€ë¹„", "ìŠ¤í‚¬", "ê³„íš", "ì „ëµ", "íŠ¹í™”"]},
                {"text": "ì•½ì ë³´ë‹¤ëŠ” ì •ë©´ìŠ¹ë¶€", "tags": ["ì •ë©´ìŠ¹ë¶€", "ì§ì ‘", "ë‹¹ë‹¹í•¨", "ê°•í•¨", "ì •ì§"]}
            ]
        },
        {
            "question": "ìƒˆë¡œìš´ ì¥ë¹„ë¥¼ ì–»ì—ˆì„ ë•Œ ìš°ì„ ìˆœìœ„ëŠ”?",
            "answers": [
                {"text": "ê³µê²©ë ¥ì´ ë†’ì€ ë¬´ê¸°", "tags": ["ê³µê²©ë ¥", "ë¬´ê¸°", "ë”œëŸ¬", "ê°•í•¨", "ë°ë¯¸ì§€"]},
                {"text": "ë°©ì–´ë ¥ì´ ë†’ì€ ë°©ì–´êµ¬", "tags": ["ë°©ì–´ë ¥", "ë°©ì–´êµ¬", "íƒ±ì»¤", "ìƒì¡´", "ì•ˆì „"]},
                {"text": "íŠ¹ìˆ˜ íš¨ê³¼ê°€ ìˆëŠ” ì¥ë¹„", "tags": ["íŠ¹ìˆ˜íš¨ê³¼", "ìœ ë‹ˆí¬", "ê¸°ëŠ¥", "ë‹¤ì–‘í•¨", "íŠ¹ë³„"]},
                {"text": "ì„¸íŠ¸ íš¨ê³¼ë¥¼ ë§ì¶œ ìˆ˜ ìˆëŠ” ì¥ë¹„", "tags": ["ì„¸íŠ¸íš¨ê³¼", "ì¡°í•©", "ì‹œë„ˆì§€", "ì™„ì„±", "ì²´ê³„"]}
            ]
        },
        {
            "question": "íŒŒí‹° êµ¬ì„±ì—ì„œ ê°€ì¥ ì‹ ê²½ì“°ëŠ” ë¶€ë¶„ì€?",
            "answers": [
                {"text": "ê° ì—­í• ì˜ ê· í˜•", "tags": ["ê· í˜•", "ì—­í• ", "ì•ˆì •", "ì²´ê³„", "ì™„ì„±"]},
                {"text": "ê°•ë ¥í•œ ì‹œë„ˆì§€ íš¨ê³¼", "tags": ["ì‹œë„ˆì§€", "ì¡°í•©", "ìƒìŠ¹íš¨ê³¼", "í˜‘ë ¥", "ê°•í™”"]},
                {"text": "ê°œì„± ìˆëŠ” ìºë¦­í„°ë“¤", "tags": ["ê°œì„±", "ë‹¤ì–‘í•¨", "íŠ¹ìƒ‰", "ìœ ë‹ˆí¬", "ì¬ë¯¸"]},
                {"text": "ìƒí™© ëŒ€ì‘ ëŠ¥ë ¥", "tags": ["ëŒ€ì‘ëŠ¥ë ¥", "ìœ ì—°", "ì ì‘", "ë³€í™”", "ë²”ìš©"]}
            ]
        },
        {
            "question": "ì „íˆ¬ì—ì„œ ê°€ì¥ ë§Œì¡±ìŠ¤ëŸ¬ìš´ ìˆœê°„ì€?",
            "answers": [
                {"text": "ì™„ë²½í•œ íƒ€ì´ë°ì˜ ìŠ¤í‚¬ ì‚¬ìš©", "tags": ["íƒ€ì´ë°", "ì™„ë²½", "ìŠ¤í‚¬", "ì •ë°€", "ê¸°ìˆ "]},
                {"text": "ì˜ˆìƒë³´ë‹¤ ë†’ì€ ë°ë¯¸ì§€ê°€ ë‚˜ì˜¬ ë•Œ", "tags": ["ë†’ì€ë°ë¯¸ì§€", "ì˜ˆìƒì´ˆê³¼", "ë†€ë¼ì›€", "ê°•ë ¥", "ì„±ê³¼"]},
                {"text": "ìœ„ê¸°ë¥¼ ëª¨ë©´í–ˆì„ ë•Œ", "tags": ["ìœ„ê¸°ëª¨ë©´", "ìƒì¡´", "ì•ˆë„", "ê·¹ë³µ", "íšŒë³µ"]},
                {"text": "íŒ€ì›ì„ êµ¬í•´ëƒˆì„ ë•Œ", "tags": ["êµ¬ì¡°", "ë„ì›€", "í¬ìƒ", "ë³´í˜¸", "ì˜ì›…"]}
            ]
        },
        {
            "question": "ë§ˆë²•ê³¼ ë¬¼ë¦¬ ê³µê²© ì¤‘ ì„ í˜¸í•˜ëŠ” ê²ƒì€?",
            "answers": [
                {"text": "í™”ë ¤í•˜ê³  ê°•ë ¥í•œ ë§ˆë²•", "tags": ["ë§ˆë²•", "í™”ë ¤", "ê°•ë ¥", "ì‹ ë¹„", "ì›ì†Œ"]},
                {"text": "í™•ì‹¤í•˜ê³  ì§ì ‘ì ì¸ ë¬¼ë¦¬ ê³µê²©", "tags": ["ë¬¼ë¦¬", "ì§ì ‘", "í™•ì‹¤", "ê·¼ì ‘", "ë‹¨ìˆœ"]},
                {"text": "ë§ˆë²•ê³¼ ë¬¼ë¦¬ë¥¼ ì¡°í•©", "tags": ["ì¡°í•©", "í•˜ì´ë¸Œë¦¬ë“œ", "ë‹¤ì–‘", "ë³µí•©", "ê· í˜•"]},
                {"text": "ìƒí™©ì— ë”°ë¼ ì„ íƒ", "tags": ["ìƒí™©ëŒ€ì‘", "ì„ íƒ", "ìœ ì—°", "ì ì‘", "ì „ëµ"]}
            ]
        },
        {
            "question": "ê²Œì„ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ì¬ë¯¸ ìš”ì†ŒëŠ”?",
            "answers": [
                {"text": "ê°•í•´ì§€ëŠ” ì„±ì¥ì˜ ì¬ë¯¸", "tags": ["ì„±ì¥", "ê°•í™”", "ë°œì „", "ì§„ë³´", "í–¥ìƒ"]},
                {"text": "ìƒˆë¡œìš´ ê²ƒì„ ë°œê²¬í•˜ëŠ” ì¬ë¯¸", "tags": ["ë°œê²¬", "ìƒˆë¡œì›€", "íƒí—˜", "í˜¸ê¸°ì‹¬", "ëª¨í—˜"]},
                {"text": "ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜í•˜ëŠ” ì¬ë¯¸", "tags": ["ì¹œêµ¬", "í•¨ê»˜", "ì†Œì…œ", "ê³µìœ ", "ìœ ëŒ€"]},
                {"text": "ë„ì „ê³¼ ê·¹ë³µì˜ ì¬ë¯¸", "tags": ["ë„ì „", "ê·¹ë³µ", "ì„±ì·¨", "ìŠ¹ë¦¬", "ë§Œì¡±"]}
            ]
        },
        {
            "question": "ì´ìƒì ì¸ ìºë¦­í„° ë¹Œë“œëŠ”?",
            "answers": [
                {"text": "í•œ ë¶„ì•¼ì— íŠ¹í™”ëœ ì „ë¬¸ê°€", "tags": ["ì „ë¬¸ê°€", "íŠ¹í™”", "ì§‘ì¤‘", "ë§ˆìŠ¤í„°", "ê¹Šì´"]},
                {"text": "ì—¬ëŸ¬ ë¶„ì•¼ë¥¼ ì•„ìš°ë¥´ëŠ” ë§ŒëŠ¥í˜•", "tags": ["ë§ŒëŠ¥", "ë‹¤ì¬ë‹¤ëŠ¥", "ê· í˜•", "ë²”ìš©", "ìœ ì—°"]},
                {"text": "ë…íŠ¹í•œ ì»¨ì…‰ì˜ ê°œì„±íŒŒ", "tags": ["ê°œì„±", "ë…íŠ¹", "ì»¨ì…‰", "íŠ¹ë³„", "ìœ ë‹ˆí¬"]},
                {"text": "íŒ€ì— ê¼­ í•„ìš”í•œ í•µì‹¬ ì—­í• ", "tags": ["í•µì‹¬", "í•„ìˆ˜", "ì¤‘ìš”", "ì—­í• ", "ì±…ì„"]}
            ]
        }
    ]
    
    # íƒœê·¸ë³„ ì§ì—… ë§¤í•‘ (í™•ì¥í˜•)
    TAG_TO_CLASSES = {
        # ìŠ¤íƒ€ì¼ íƒœê·¸
        "ì†ë„": ["ê¶ìˆ˜", "ì•”ì‚´ì", "ë„ì ", "ì‚¬ë¬´ë¼ì´", "ê´‘ì „ì‚¬"],
        "ë”œëŸ¬": ["ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê¶ìˆ˜", "ì•”ì‚´ì", "ë„ì ", "í•´ì ", "ì‚¬ë¬´ë¼ì´"],
        "í¬ë¦¬í‹°ì»¬": ["ê¶ìˆ˜", "ì•”ì‚´ì", "ì‚¬ë¬´ë¼ì´", "í•´ì "],
        "íƒ±ì»¤": ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ê²€íˆ¬ì‚¬", "ìš©ê¸°ì‚¬"],
        "ìƒì¡´": ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ì‹ ê´€", "ë“œë£¨ì´ë“œ"],
        "ë°©ì–´": ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ê²€íˆ¬ì‚¬"],
        "ë§ˆë²•": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬"],
        "ì›ì†Œ": ["ì•„í¬ë©”ì´ì§€", "ì •ë ¹ìˆ ì‚¬", "ë§ˆê²€ì‚¬", "ìš©ê¸°ì‚¬"],
        "AOE": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì—°ê¸ˆìˆ ì‚¬"],
        "í•˜ì´ë¸Œë¦¬ë“œ": ["ì•”í‘ê¸°ì‚¬", "ëª½í¬", "ê¸°ê³„ê³µí•™ì", "ë§ˆê²€ì‚¬"],
        "ì„œí¬í„°": ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹", "ì² í•™ì"],
        "íë§": ["ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë°”ë“œ", "ì„±ê¸°ì‚¬"],
        "íŠ¹ìˆ˜": ["ì‹œê°„ìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë¬´ë‹¹", "ì² í•™ì", "í•´ì "],
        "ìœ ë‹ˆí¬": ["ë„¤í¬ë¡œë§¨ì„œ", "ê¸°ê³„ê³µí•™ì", "ë¬´ë‹¹", "ì² í•™ì"],
        
        # ì „íˆ¬ ìŠ¤íƒ€ì¼ íƒœê·¸
        "ê³µê²©ì ": ["ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬", "ì•”ì‚´ì"],
        "ì‹ ì¤‘": ["ê¶ìˆ˜", "ì² í•™ì", "ì‹œê°„ìˆ ì‚¬", "ì„±ê¸°ì‚¬"],
        "ë¶„ì„": ["ì² í•™ì", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬"],
        "ì „ëµ": ["ì‹œê°„ìˆ ì‚¬", "ì² í•™ì", "ê¸°ê³„ê³µí•™ì", "ë°”ë“œ"],
        "ì§€ì›": ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹"],
        "í˜‘ë ¥": ["ë°”ë“œ", "ì„±ê¸°ì‚¬", "ì‹ ê´€", "ê¸°ì‚¬"],
        
        # ìì› ê´€ë¦¬ íƒœê·¸
        "HPì†Œëª¨": ["ê´‘ì „ì‚¬", "ì•”í‘ê¸°ì‚¬", "ë¬´ë‹¹"],
        "MPê´€ë¦¬": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬"],
        "ìŠ¤íƒ": ["ê²€ì„±", "ê²€íˆ¬ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ê¶ìˆ˜", "ê¸°ì‚¬"],
        "ê²Œì´ì§€": ["ì‚¬ë¬´ë¼ì´", "ë°”ë“œ", "ë“œë£¨ì´ë“œ"],
        "íŠ¹ìˆ˜ìì›": ["ë„¤í¬ë¡œë§¨ì„œ", "í•´ì ", "ê¸°ê³„ê³µí•™ì"],
        
        # ì—­í•  íƒœê·¸
        "ìˆ˜í˜¸": ["ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ì „ì‚¬"],
        "ì²˜ì¹˜": ["ê²€ì„±", "ê²€íˆ¬ì‚¬", "ì•”ì‚´ì", "í•´ì "],
        "ì§€ë°°": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì‹œê°„ìˆ ì‚¬"],
        "ë„ì›€": ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹"],
        
        # ê¸°ë¯¹ íƒœê·¸
        "í­ë°œ": ["ì—°ê¸ˆìˆ ì‚¬", "ì•„í¬ë©”ì´ì§€", "ê´‘ì „ì‚¬"],
        "íšŒí”¼": ["ì°¨ì›ìˆ ì‚¬", "ì•”ì‚´ì", "ì‚¬ë¬´ë¼ì´"],
        "ë°˜ê²©": ["ê²€íˆ¬ì‚¬", "ì‚¬ë¬´ë¼ì´", "ê¸°ì‚¬"],
        "ì¡°í•©": ["ì•„í¬ë©”ì´ì§€", "ì •ë ¹ìˆ ì‚¬", "ë§ˆê²€ì‚¬", "ì—°ê¸ˆìˆ ì‚¬"],
        "ì—°ê³„": ["ë°”ë“œ", "ëª½í¬", "ê¸°ê³„ê³µí•™ì"],
        
        # ëŠ¥ë ¥ì¹˜ íƒœê·¸
        "ê³µê²©ë ¥": ["ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬"],
        "ë°©ì–´ë ¥": ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬"],
        "ë¯¼ì²©": ["ë„ì ", "ì•”ì‚´ì", "ê¶ìˆ˜"],
        "ë§ˆë²•ë ¥": ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬"]
    }
    
    # íŠ¹ì„± íƒœê·¸ ë§¤í•‘ (ì§ˆë¬¸ ê¸°ë°˜ìœ¼ë¡œ íŠ¹ì„±ë„ ì¶”ì²œ) - 6ë‹¨ê³„ ì™„ì „ì²´ ì‹œìŠ¤í…œ
    TAG_TO_TRAITS = {
        "ê³µê²©ì ": ["6ë‹¨ê³„ ì™„ì „ì²´", "ì „ì¥ì˜ ì§€ë°°ì", "íŒ¨ë§ ë§ˆìŠ¤í„°", "í”¼ì˜ ê°ˆì¦"],
        "ë°©ì–´": ["6ë‹¨ê³„ ì™„ì „ì²´", "ì‹ ì„±í•œ ë³´í˜¸", "ìˆ˜í˜¸ ë³¸ëŠ¥", "ë¶ˆêµ´ì˜ ì˜ì§€"],
        "ë§ˆë²•": ["ì›ì†Œ ë§ˆìŠ¤í„°", "ë§ˆë ¥ ì¡°ì ˆ", "ì •ë ¹ ì†Œí†µ", "ì‹œê°„ ì¡°ì‘"],
        "ì§€ì›": ["íŒŒí‹° ì§€ì›", "ì¹˜ìœ  ì „ë¬¸ê°€", "ì‹ ì„± ê°€í˜¸", "ìŒì•… ì¬ëŠ¥"],
        "ì†ë„": ["6ë‹¨ê³„ ì™„ì „ì²´", "ì •ë°€í•¨", "ì§‘ì¤‘ë ¥", "ê·¸ë¦¼ì ì¡°ì‘"],
        "ìƒì¡´": ["ìƒëª…ë ¥ ì¡°ì‘", "ì¹˜ìœ ìˆ ", "ìì—° ì†Œí†µ", "ì˜ì  ë³´í˜¸"],
        "ìŠ¤íƒ": ["ê²€ê¸° ì¡°ì‘", "íˆ¬ê¸°ì¥ì˜ ê²½í—˜", "ê³µê°„ ì¡°ì‘", "ë¶„ì„ ëŠ¥ë ¥"],
        "íŠ¹ìˆ˜": ["ì˜í˜¼ ì¡°ì‘", "ì‹œê°„ ì¡°ì‘", "ê¸°ê³„ ì¡°ì‘", "ë…¼ë¦¬ì  ì‚¬ê³ "],
        "íŒ€ì›Œí¬": ["íŒŒí‹° ì§€ì›", "ê¸°ì‚¬ë„ ì •ì‹ ", "ì‹ ì„±í•œ ë³´í˜¸", "ìŒì•… ì¬ëŠ¥"]
    }

    def create_question_based_party(self, party_size: int = 4) -> List[Character]:
        """ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ì¶”ì²œ ì‹œìŠ¤í…œ - ì»¤ì„œ ë©”ë‰´ ë²„ì „"""
        try:
            from game.cursor_menu_system import CursorMenu
            
            print(f"\n{CYAN}ğŸ¯ ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ì¶”ì²œ ì‹œìŠ¤í…œ{RESET}")
            print(f"{WHITE}8ê°€ì§€ ì§ˆë¬¸ì— ë‹µí•˜ì‹œë©´ ë§ì¶¤í˜• íŒŒí‹°ë¥¼ ì¶”ì²œí•´ë“œë¦½ë‹ˆë‹¤!{RESET}")
            print(f"{YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”{RESET}")
            
            # ëœë¤ìœ¼ë¡œ 8ê°œ ì§ˆë¬¸ ì„ íƒ
            num_questions = min(8, len(self.PARTY_QUESTIONS))
            selected_questions = random.sample(self.PARTY_QUESTIONS, num_questions)
            user_tags = []
            
            for i, question_data in enumerate(selected_questions, 1):
                # ì»¤ì„œ ë©”ë‰´ë¡œ ì§ˆë¬¸ê³¼ ë‹µë³€ í‘œì‹œ
                options = [answer['text'] for answer in question_data['answers']]
                
                # ì§ˆë¬¸ê³¼ ì§„í–‰ìƒí™©ì„ í¬í•¨í•œ ì œëª©
                title = f"ì§ˆë¬¸ {i}/{num_questions}: {question_data['question']}"
                
                # ì»¤ì„œ ë©”ë‰´ ìƒì„±
                menu = CursorMenu(
                    title=title,
                    options=options,
                    cancellable=True
                )
                
                # ì„ íƒ ë°›ê¸°
                result = menu.run()
                
                if result is None:  # ì·¨ì†Œëœ ê²½ìš°
                    print(f"\n{RED}âŒ íŒŒí‹° ì¶”ì²œ ì·¨ì†Œ{RESET}")
                    return None
                
                # ì„ íƒëœ ë‹µë³€ì˜ íƒœê·¸ ì¶”ê°€
                selected_answer = question_data['answers'][result]
                user_tags.extend(selected_answer['tags'])
                print(f"{MAGENTA}â†’ ì„ íƒ: {selected_answer['text']}{RESET}")
            
            # íƒœê·¸ ë¶„ì„í•˜ì—¬ íŒŒí‹° êµ¬ì„±
            print(f"\n{CYAN}ğŸ¤” ë‹µë³€ì„ ë¶„ì„ì¤‘...{RESET}")
            recommended_party = self._analyze_tags_and_build_party(user_tags, party_size)
            
            # ìƒì„±ëœ íŒŒí‹° ì •ë³´ í‘œì‹œ
            if recommended_party:
                self._display_party_summary(recommended_party)
                # ë™ì  ë‚œì´ë„ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
                self._update_difficulty_scaling(recommended_party)
            
            print(f"\n{GREEN}âœ¨ ë§ì¶¤í˜• íŒŒí‹°ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
            return recommended_party
            
        except ImportError:
            # ì»¤ì„œ ë©”ë‰´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
            return self.create_question_based_party_fallback(party_size)
    
    def create_question_based_party_fallback(self, party_size: int = 4) -> List[Character]:
        """ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ì¶”ì²œ ì‹œìŠ¤í…œ - ê¸°ë³¸ ë²„ì „ (í´ë°±)"""
        print(f"\n{CYAN}ğŸ¯ ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ì¶”ì²œ ì‹œìŠ¤í…œ{RESET}")
        print(f"{WHITE}8ê°€ì§€ ì§ˆë¬¸ì— ë‹µí•˜ì‹œë©´ ë§ì¶¤í˜• íŒŒí‹°ë¥¼ ì¶”ì²œí•´ë“œë¦½ë‹ˆë‹¤!{RESET}")
        print(f"{YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”{RESET}")
        
        # ëœë¤ìœ¼ë¡œ 8ê°œ ì§ˆë¬¸ ì„ íƒ
        num_questions = min(8, len(self.PARTY_QUESTIONS))
        selected_questions = random.sample(self.PARTY_QUESTIONS, num_questions)
        user_tags = []
        
        for i, question_data in enumerate(selected_questions, 1):
            print(f"\n{GREEN}ì§ˆë¬¸ {i}/{num_questions}: {question_data['question']}{RESET}")
            print()
            
            # ë‹µë³€ ì„ íƒì§€ í‘œì‹œ
            for j, answer in enumerate(question_data['answers'], 1):
                print(f"  {j}. {answer['text']}")
            
            print(f"\n{BLUE}ì„ íƒí•˜ì„¸ìš” (1-{len(question_data['answers'])}): {RESET}", end="")
            
            # ì‚¬ìš©ì ì…ë ¥ ë°›ê¸°
            while True:
                try:
                    choice = self.keyboard.get_key()
                    if choice.isdigit():
                        choice_num = int(choice)
                        if 1 <= choice_num <= len(question_data['answers']):
                            selected_answer = question_data['answers'][choice_num - 1]
                            user_tags.extend(selected_answer['tags'])
                            print(f"{choice_num}")
                            print(f"{MAGENTA}â†’ {selected_answer['text']}{RESET}")
                            break
                    print(f"\n{RED}ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤. 1-{len(question_data['answers'])} ì¤‘ì—ì„œ ì„ íƒí•´ì£¼ì„¸ìš”: {RESET}", end="")
                except KeyboardInterrupt:
                    print(f"\n{RED}âŒ íŒŒí‹° ì¶”ì²œ ì·¨ì†Œ{RESET}")
                    return None
        
        # íƒœê·¸ ë¶„ì„í•˜ì—¬ íŒŒí‹° êµ¬ì„±
        print(f"\n{CYAN}ğŸ¤” ë‹µë³€ì„ ë¶„ì„ì¤‘...{RESET}")
        recommended_party = self._analyze_tags_and_build_party(user_tags, party_size)
        
        print(f"\n{GREEN}âœ¨ ë§ì¶¤í˜• íŒŒí‹°ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
        return recommended_party
    
    def _analyze_tags_and_build_party(self, user_tags: List[str], party_size: int) -> List[Character]:
        """íƒœê·¸ ë¶„ì„í•˜ì—¬ íŒŒí‹° êµ¬ì„±"""
        # íƒœê·¸ë³„ ì ìˆ˜ ê³„ì‚°
        class_scores = {}
        trait_scores = {}
        
        # ëª¨ë“  ì§ì—… ì´ˆê¸°í™”
        for class_name in self.ALL_CLASSES:
            class_scores[class_name] = 0
        
        # íƒœê·¸ë³„ ì ìˆ˜ ë¶€ì—¬
        for tag in user_tags:
            # ì§ì—… ì ìˆ˜
            if tag in self.TAG_TO_CLASSES:
                for class_name in self.TAG_TO_CLASSES[tag]:
                    class_scores[class_name] += 1
            
            # íŠ¹ì„± ì ìˆ˜
            if tag in self.TAG_TO_TRAITS:
                for trait_name in self.TAG_TO_TRAITS[tag]:
                    trait_scores[trait_name] = trait_scores.get(trait_name, 0) + 1
        
        # ì—­í•  ê· í˜• ë³´ì •
        selected_classes = []
        used_roles = set()
        
        # ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
        sorted_classes = sorted(class_scores.items(), key=lambda x: x[1], reverse=True)
        
        # ì—­í•  ë‹¤ì–‘ì„±ì„ ê³ ë ¤í•˜ì—¬ ì„ íƒ
        for class_name, score in sorted_classes:
            if len(selected_classes) >= party_size:
                break
            
            # í˜„ì¬ ì§ì—…ì˜ ì—­í•  í™•ì¸
            class_role = self._get_character_role(class_name)
            
            # ê°™ì€ ì—­í• ì´ ë„ˆë¬´ ë§ìœ¼ë©´ íŒ¨ìŠ¤ (ìµœëŒ€ 2ëª…)
            role_count = sum(1 for selected in selected_classes if self._get_character_role(selected) == class_role)
            if role_count >= 2:
                continue
            
            selected_classes.append(class_name)
            used_roles.add(class_role)
        
        # ì—­í• ì´ ë¶€ì¡±í•˜ë©´ ë³´ì™„
        while len(selected_classes) < party_size:
            missing_roles = set(["íƒ±ì»¤", "ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"]) - used_roles
            if missing_roles:
                missing_role = random.choice(list(missing_roles))
                available_for_role = [c for c in self.ROLE_CLASSES.get(missing_role, []) 
                                    if c not in selected_classes]
                if available_for_role:
                    selected_classes.append(random.choice(available_for_role))
                    used_roles.add(missing_role)
                else:
                    # ì‚¬ìš© ê°€ëŠ¥í•œ ì§ì—…ì´ ì—†ìœ¼ë©´ ì•„ë¬´ê±°ë‚˜ ì¶”ê°€
                    remaining = [c for c in self.ALL_CLASSES if c not in selected_classes]
                    if remaining:
                        selected_classes.append(random.choice(remaining))
            else:
                # ëª¨ë“  ì—­í• ì´ ìˆìœ¼ë©´ ì•„ë¬´ê±°ë‚˜ ì¶”ê°€
                remaining = [c for c in self.ALL_CLASSES if c not in selected_classes]
                if remaining:
                    selected_classes.append(random.choice(remaining))
                else:
                    break
        
        # ìºë¦­í„° ìƒì„±
        party_members = []
        self._used_names = set()  # ì´ë¦„ ì¤‘ë³µ ë°©ì§€ ì´ˆê¸°í™”
        
        for i, class_name in enumerate(selected_classes):
            character = self._create_character(class_name, i + 1)
            
            # ì‚¬ìš©ìê°€ ì§ì ‘ íŠ¹ì„± ì„ íƒ (AI ì¶”ì²œ ê¸°ë°˜ íŒíŠ¸ ì œê³µ)
            self._ai_assisted_select_passives(character, user_tags)
            
            # ì‹œì‘ ì¥ë¹„ ì œê³µ
            self._provide_starting_equipment(character)
            
            party_members.append(character)
        
        # íŒŒí‹° ë¶„ì„
        self._analyze_question_based_party(party_members, user_tags)
        
        # ğŸŒŸ íŒ¨ì‹œë¸Œ íš¨ê³¼ ì„ íƒ
        selected_passives = self.select_party_passives(party_members, user_tags)
        
        # íŒŒí‹°ì— íŒ¨ì‹œë¸Œ ì •ë³´ ì €ì¥ (ê²Œì„ì—ì„œ ì ìš©í•  ìˆ˜ ìˆë„ë¡)
        for member in party_members:
            if not hasattr(member, 'party_passives'):
                member.party_passives = selected_passives
        
        # ğŸ ëª¨ë“  ìºë¦­í„°ì—ê²Œ ìŠ¤íƒ€íŒ… ì•„ì´í…œ ì§€ê¸‰
        self._give_starting_items_to_party(party_members)
        
        return party_members
    
    def _auto_select_traits_by_tags(self, character: Character, user_tags: List[str], trait_scores: Dict[str, int]):
        """ì§ˆë¬¸ íƒœê·¸ ê¸°ë°˜ íŠ¹ì„± ìë™ ì„ íƒ (ê°œë°œ ëª¨ë“œì—ì„œëŠ” 2ê°œ ì„ íƒ)"""
        print(f"\n{CYAN}ğŸ¯ {character.name}ì˜ íŠ¹ì„± ì„ íƒ ì¤‘...{RESET}")
        
        if not character.available_traits:
            print(f"{YELLOW}  âš ï¸ ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ì—†ìŠµë‹ˆë‹¤{RESET}")
            return
        
        # ê°œë°œ ëª¨ë“œ í™•ì¸
        try:
            from config import game_config
            is_dev_mode = hasattr(game_config, 'DEVELOPMENT_MODE') and game_config.DEVELOPMENT_MODE
        except:
            is_dev_mode = False
        
        # ê°œë°œ ëª¨ë“œê°€ ì•„ë‹Œ ê²½ìš° í•´ê¸ˆëœ íŠ¹ì„±ë§Œ ì„ íƒ ê°€ëŠ¥
        if not is_dev_mode:
            unlocked_traits = character._get_unlocked_traits()
            available_indices = []
            for i, trait in enumerate(character.available_traits):
                if trait.name in unlocked_traits:
                    available_indices.append(i)
            
            if not available_indices:
                character.select_passive_traits([])
                return
            
            # í•´ê¸ˆëœ íŠ¹ì„± ì¤‘ì—ì„œ 1ê°œ ì„ íƒ
            self._select_best_trait_combination(character, available_indices, user_tags, trait_scores)
        else:
            # ê°œë°œ ëª¨ë“œ: ì§ˆë¬¸ íƒœê·¸ + ì§ì—… íŠ¹ì„±ì„ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ 2ê°œ ì„ íƒ
            trait_priority_scores = {}
            
            # ê¸°ë³¸ ì§ì—… íŠ¹ì„± ìš°ì„ ìˆœìœ„
            class_priorities = self._get_trait_priorities(character.character_class)
            
            for i, trait in enumerate(character.available_traits):
                score = 0
                
                # ì§ì—…ë³„ ê¸°ë³¸ ìš°ì„ ìˆœìœ„
                if trait.name in class_priorities:
                    score += class_priorities[trait.name]
                
                # ì§ˆë¬¸ íƒœê·¸ ê¸°ë°˜ ë³´ë„ˆìŠ¤
                if trait.name in trait_scores:
                    score += trait_scores[trait.name] * 3  # ì§ˆë¬¸ ê¸°ë°˜ ê°€ì¤‘ì¹˜
                
                # ì‚¬ìš©ì íƒœê·¸ì™€ íŠ¹ì„± ì—°ê´€ì„± ì²´í¬
                for tag in user_tags:
                    if tag in self.TAG_TO_TRAITS and trait.name in self.TAG_TO_TRAITS[tag]:
                        score += 2
                
                trait_priority_scores[i] = score
            
            # ê°œë°œ ëª¨ë“œì—ì„œëŠ” 2ê°œ ì„ íƒ
            available_indices = list(range(len(character.available_traits)))
            self._select_best_trait_combination_dev_mode(character, available_indices, user_tags, trait_scores, trait_priority_scores)
    
    def _select_best_trait_combination(self, character: Character, available_indices: List[int], 
                                     user_tags: List[str], trait_scores: Dict[str, int], 
                                     priority_scores: Dict[int, int] = None):
        """ìµœì ì˜ íŠ¹ì„± ì„ íƒ (ì½”ìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì œê±°)"""
        if not available_indices:
            character.select_passive_traits([])
            return
        
        # ìš°ì„ ìˆœìœ„ ì ìˆ˜ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê³„ì‚°
        if priority_scores is None:
            priority_scores = {}
            class_priorities = self._get_trait_priorities(character.character_class)
            
            for i in available_indices:
                trait = character.available_traits[i]
                score = class_priorities.get(trait.name, 0)
                
                # ì§ˆë¬¸ íƒœê·¸ ê¸°ë°˜ ë³´ë„ˆìŠ¤
                if trait.name in trait_scores:
                    score += trait_scores[trait.name] * 3
                
                for tag in user_tags:
                    if tag in self.TAG_TO_TRAITS and trait.name in self.TAG_TO_TRAITS[tag]:
                        score += 2
                
                priority_scores[i] = score
        
        # ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ íŠ¹ì„± 1ê°œ ì„ íƒ
        if available_indices:
            best_trait = max(available_indices, key=lambda i: priority_scores.get(i, 0))
            character.select_passive_traits([best_trait])
            trait_name = character.available_traits[best_trait].name
            print(f"{GREEN}  âœ… {character.name} - ì„ íƒëœ íŠ¹ì„±: {trait_name}{RESET}")
        else:
            character.select_passive_traits([])
            print(f"{YELLOW}  âš ï¸ {character.name} - ì„ íƒëœ íŠ¹ì„± ì—†ìŒ{RESET}")

    def select_party_passives(self, party: List[Character], user_tags: List[str]):
        """ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹°ì— ë§ëŠ” íŒ¨ì‹œë¸Œ ì„ íƒ"""
        print(f"\n{GREEN}=== ğŸŒŸ íŒŒí‹° íŒ¨ì‹œë¸Œ íš¨ê³¼ ì„ íƒ ==={RESET}")
        
        # ğŸŒŸ ì™„ì „ ë¦¬ë©”ì´í¬ëœ ì°½ì˜ì  íŒ¨ì‹œë¸Œ ì‹œìŠ¤í…œ
        all_passive_effects = [
            # === 1ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ê¸°ì´ˆ íš¨ê³¼) ===
            {
                "name": "ì²«ê±¸ìŒì˜ ìš©ê¸°", 
                "description": "ì²« ë²ˆì§¸ ì „íˆ¬ì—ì„œ ëª¨ë“  ëŠ¥ë ¥ì¹˜ +50%",
                "effect_type": "first_battle_boost",
                "effect_value": {"all_stats": 0.50},
                "cost": 1,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ë¯¸ë‹ˆë©€ë¦¬ìŠ¤íŠ¸", 
                "description": "ì¸ë²¤í† ë¦¬ 50% ì´í•˜ì¼ ë•Œ SPD +15%, íšŒí”¼ìœ¨ +10%",
                "effect_type": "minimalist",
                "effect_value": {"speed_bonus": 0.15, "dodge_bonus": 0.10, "inventory_threshold": 0.50},
                "cost": 1,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ìƒˆë²½ì˜ ì§‘ì¤‘", 
                "description": "ì „íˆ¬ ì²« í„´ì— í–‰ë™ì†ë„ +100%",
                "effect_type": "dawn_focus",
                "effect_value": {"first_turn_speed": 1.00},
                "cost": 1,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ì ˆì•½ ì •ì‹ ", 
                "description": "ì•„ì´í…œ ì‚¬ìš© ì‹œ 25% í™•ë¥ ë¡œ ì†Œëª¨í•˜ì§€ ì•ŠìŒ",
                "effect_type": "conservation",
                "effect_value": {"save_chance": 0.25},
                "cost": 1,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "í–‰ìš´ì˜ ë™ì „", 
                "description": "ê³¨ë“œ ìŠµë“ ì‹œ 10% í™•ë¥ ë¡œ 2ë°°",
                "effect_type": "lucky_coin",
                "effect_value": {"double_chance": 0.10},
                "cost": 1,
                "unlock_cost": 0,
                "rarity": "common"
            },
            
            # === 2ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ì‘ìš© íš¨ê³¼) ===
            {
                "name": "ì—­ì „ì˜ ëª…ìˆ˜", 
                "description": "HP 25% ì´í•˜ì¼ ë•Œ í¬ë¦¬í‹°ì»¬ í™•ë¥  +30%",
                "effect_type": "comeback_master",
                "effect_value": {"crit_bonus": 0.30, "hp_threshold": 0.25},
                "cost": 2,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ëª¨í—˜ê°€ì˜ ì§ê°", 
                "description": "ìˆ¨ê²¨ì§„ ë¬¸ ë°œê²¬ìœ¨ +40%, í•¨ì • ê°ì§€ +25%",
                "effect_type": "adventurer_instinct",
                "effect_value": {"secret_find": 0.40, "trap_detect": 0.25},
                "cost": 2,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ì—°ì‡„ ë°˜ì‘", 
                "description": "í¬ë¦¬í‹°ì»¬ íˆíŠ¸ ì‹œ ë‹¤ìŒ ê³µê²© ë°ë¯¸ì§€ +20% (3íšŒ ì¤‘ì²©)",
                "effect_type": "chain_reaction",
                "effect_value": {"damage_boost": 0.20, "max_stacks": 3},
                "cost": 2,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ìˆ˜ì§‘ê°€ì˜ ëˆˆ", 
                "description": "ë ˆì–´ ì•„ì´í…œ ë°œê²¬ìœ¨ +20%, ì¤‘ë³µ ì•„ì´í…œ ì‹œ ê³¨ë“œ ë³´ë„ˆìŠ¤ +50%",
                "effect_type": "collector_eye",
                "effect_value": {"rare_find": 0.20, "duplicate_bonus": 0.50},
                "cost": 2,
                "unlock_cost": 0,
                "rarity": "common"
            },
            {
                "name": "ì¼ì‚¬ì²œë¦¬", 
                "description": "ê°™ì€ ìŠ¤í‚¬ ì—°ì† ì‚¬ìš© ì‹œ MP ì†Œëª¨ -10% (ìµœëŒ€ -50%)",
                "effect_type": "momentum",
                "effect_value": {"mp_reduction": 0.10, "max_reduction": 0.50},
                "cost": 2,
                "unlock_cost": 30,
                "rarity": "uncommon"
            },
            {
                "name": "ìœ„ê¸° ëŒ€ì‘", 
                "description": "ìƒíƒœì´ìƒ ê±¸ë¦´ ë•Œ ì¦‰ì‹œ HP 15% íšŒë³µ",
                "effect_type": "crisis_response",
                "effect_value": {"heal_percent": 0.15},
                "cost": 2,
                "unlock_cost": 40,
                "rarity": "uncommon"
            },
            
            # === 3ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ì „ëµì  íš¨ê³¼) ===
            {
                "name": "ì™„ë²½ì£¼ì˜ì", 
                "description": "í’€ HP/MPì¼ ë•Œ ëª¨ë“  í–‰ë™ íš¨ê³¼ +25%",
                "effect_type": "perfectionist",
                "effect_value": {"effect_boost": 0.25},
                "cost": 3,
                "unlock_cost": 50,
                "rarity": "uncommon"
            },
            {
                "name": "ë„ë°•ê¾¼ì˜ ì‹¬ë¦¬", 
                "description": "ê³µê²©/ìŠ¤í‚¬ ì‚¬ìš© ì‹œ 10% í™•ë¥ ë¡œ 2ë°° íš¨ê³¼, 5% í™•ë¥ ë¡œ ì‹¤íŒ¨",
                "effect_type": "gambler_mind",
                "effect_value": {"double_chance": 0.10, "fail_chance": 0.05},
                "cost": 3,
                "unlock_cost": 60,
                "rarity": "uncommon"
            },
            {
                "name": "ì‹œë„ˆì§€ ë§ˆìŠ¤í„°", 
                "description": "íŒŒí‹°ì›ê³¼ ê°™ì€ íƒ€ê²Ÿ ê³µê²© ì‹œ ë°ë¯¸ì§€ +35%",
                "effect_type": "synergy_master",
                "effect_value": {"synergy_damage": 0.35},
                "cost": 3,
                "unlock_cost": 70,
                "rarity": "uncommon"
            },
            {
                "name": "ë³€í™”ì˜ ë‹¬ì¸", 
                "description": "ë§¤ 5í„´ë§ˆë‹¤ ëœë¤ ëŠ¥ë ¥ì¹˜ +50% (1í„´ ì§€ì†)",
                "effect_type": "change_master",
                "effect_value": {"stat_boost": 0.50, "interval": 5, "duration": 1},
                "cost": 3,
                "unlock_cost": 80,
                "rarity": "uncommon"
            },
            {
                "name": "ì—­í•™ ê´€ê³„", 
                "description": "ì•„êµ°ì´ ì£½ì„ ë•Œë§ˆë‹¤ ìƒì¡´ íŒŒí‹°ì› ëª¨ë“  ëŠ¥ë ¥ì¹˜ +15% (ëˆ„ì )",
                "effect_type": "dynamic_relationship",
                "effect_value": {"stat_per_death": 0.15},
                "cost": 3,
                "unlock_cost": 90,
                "rarity": "uncommon"
            },
            
            # === 4-10ì½”ìŠ¤íŠ¸ ê³ ê¸‰ íŒ¨ì‹œë¸Œë“¤ (ì¼ë¶€ë§Œ í‘œì‹œ) ===
            {
                "name": "ë±€íŒŒì´ì–´ ë³¸ëŠ¥", 
                "description": "ì  ì²˜ì¹˜ ì‹œ ìµœëŒ€ HPì˜ 30% íšŒë³µ, ìƒì²˜ë„ 25% ì¹˜ë£Œ",
                "effect_type": "vampire_instinct",
                "effect_value": {"hp_restore": 0.30, "wound_heal": 0.25},
                "cost": 4,
                "unlock_cost": 100,
                "rarity": "rare"
            },
            {
                "name": "ë¶„ì‹ ìˆ ", 
                "description": "ì¹˜ëª…íƒ€ ì‹œ 15% í™•ë¥ ë¡œ ì¦‰ì‹œ í•œ ë²ˆ ë” í–‰ë™",
                "effect_type": "shadow_clone",
                "effect_value": {"extra_action_chance": 0.15},
                "cost": 5,
                "unlock_cost": 150,
                "rarity": "rare"
            },
            {
                "name": "ë¶ˆì‚¬ì¡°ì˜ ì‹¬ì¥", 
                "description": "ì£½ìŒ ì‹œ 50% HPë¡œ ë¶€í™œ + 3í„´ê°„ ë¬´ì  (1íšŒ/ì¸µ)",
                "effect_type": "phoenix_heart",
                "effect_value": {"revive_hp": 0.50, "invincible_turns": 3, "uses_per_floor": 1},
                "cost": 6,
                "unlock_cost": 200,
                "rarity": "epic"
            },
            {
                "name": "ë§Œë¬¼ ë™ì¡°", 
                "description": "ëª¨ë“  ìŠ¤í‚¬ì´ ëª¨ë“  ìŠ¤íƒ¯ì„ ì‚¬ìš© (ë¬¼ë¦¬/ë§ˆë²•/ì¹˜ìœ  ë“± ëª¨ë“  íš¨ê³¼ í˜¼í•©)",
                "effect_type": "universal_sync",
                "effect_value": {"all_stat_scaling": True},
                "cost": 7,
                "unlock_cost": 300,
                "rarity": "legendary"
            },
            {
                "name": "í˜„ì‹¤ í¸ì§‘", 
                "description": "ì „íˆ¬ ì¤‘ 1íšŒ ëª¨ë“  ìƒíƒœë¥¼ ì›í•˜ëŠ” ëŒ€ë¡œ ë³€ê²½ ê°€ëŠ¥",
                "effect_type": "reality_edit",
                "effect_value": {"edit_per_battle": 1},
                "cost": 8,
                "unlock_cost": 450,
                "rarity": "mythic"
            },
            {
                "name": "ì ˆëŒ€ ë²•ì¹™", 
                "description": "ëª¨ë“  í–‰ë™ì´ ì ˆëŒ€ ì‹¤íŒ¨í•˜ì§€ ì•ŠìŒ + ëª¨ë“  í™•ë¥ ì´ ìµœëŒ€ê°’",
                "effect_type": "absolute_law",
                "effect_value": {"no_failure": True, "max_probability": True},
                "cost": 10,
                "unlock_cost": 600,
                "rarity": "mythic"
            }
        ]
        
        # ğŸ¯ íŒ¨ì‹œë¸Œ ê°œìˆ˜ ì œí•œ ì‹œìŠ¤í…œ (ìµœëŒ€ 6ê°œ)
        MAX_PASSIVE_COUNT = 6
        
        # íƒœê·¸ ê¸°ë°˜ íŒ¨ì‹œë¸Œ ì¶”ì²œ
        recommended_passives = self._get_recommended_passives_by_tags(user_tags, all_passive_effects)
        
        # ìë™ ì„ íƒëœ íŒ¨ì‹œë¸Œë“¤ í‘œì‹œ
        print(f"{BLUE}ğŸ¯ ë‹¹ì‹ ì˜ í”Œë ˆì´ ì„±í–¥ì— ë§ëŠ” ì¶”ì²œ íŒ¨ì‹œë¸Œ:{RESET}")
        
        selected_passives = []
        total_cost = 0
        
        # ì½”ìŠ¤íŠ¸ê°€ ë‚®ì€ ê²ƒë¶€í„° ìš°ì„  ì„ íƒ
        recommended_passives.sort(key=lambda x: x['cost'])
        
        for passive in recommended_passives:
            if len(selected_passives) >= MAX_PASSIVE_COUNT:
                break
            if total_cost + passive['cost'] <= 15:  # 15ì½”ìŠ¤íŠ¸ ì œí•œ
                selected_passives.append(passive)
                total_cost += passive['cost']
                
                rarity_colors = {
                    "common": "âšª", "uncommon": "ğŸ’š", "rare": "ğŸ’™", 
                    "epic": "ğŸ’œ", "legendary": "ğŸ§¡", "mythic": "â¤ï¸"
                }
                color = rarity_colors.get(passive['rarity'], 'âšª')
                
                print(f"  {color} {passive['name']} [{passive['cost']}ì½”ìŠ¤íŠ¸] - {passive['description']}")
        
        print(f"\n{GREEN}ì„ íƒëœ íŒ¨ì‹œë¸Œ: {len(selected_passives)}ê°œ, ì´ ì½”ìŠ¤íŠ¸: {total_cost}/15{RESET}")
        
        return selected_passives
    
    def _get_recommended_passives_by_tags(self, user_tags: List[str], all_passives: List[dict]) -> List[dict]:
        """íƒœê·¸ì— ë”°ë¥¸ íŒ¨ì‹œë¸Œ ì¶”ì²œ"""
        recommended = []
        
        # íƒœê·¸ë³„ ì„ í˜¸ íŒ¨ì‹œë¸Œ ë§¤í•‘
        tag_to_passives = {
            "ê³µê²©ì ": ["ì—­ì „ì˜ ëª…ìˆ˜", "ì—°ì‡„ ë°˜ì‘", "ë±€íŒŒì´ì–´ ë³¸ëŠ¥", "ë¶„ì‹ ìˆ "],
            "ë°©ì–´": ["ìœ„ê¸° ëŒ€ì‘", "ë¶ˆì‚¬ì¡°ì˜ ì‹¬ì¥", "ì™„ë²½ì£¼ì˜ì"],
            "ì†ë„": ["ìƒˆë²½ì˜ ì§‘ì¤‘", "ì¼ì‚¬ì²œë¦¬", "ë¯¸ë‹ˆë©€ë¦¬ìŠ¤íŠ¸"],
            "ë§ˆë²•": ["ë§Œë¬¼ ë™ì¡°", "ì›ì†Œ ìˆœí™˜", "ì‹œê³µê°„ ì™œê³¡"],
            "ìƒì¡´": ["ë¶ˆì‚¬ì¡°ì˜ ì‹¬ì¥", "ìœ„ê¸° ëŒ€ì‘", "ë±€íŒŒì´ì–´ ë³¸ëŠ¥"],
            "íƒí—˜": ["ëª¨í—˜ê°€ì˜ ì§ê°", "ìˆ˜ì§‘ê°€ì˜ ëˆˆ", "ë³´ë¬¼ ìì„"],
            "íŒ€ì›Œí¬": ["ì‹œë„ˆì§€ ë§ˆìŠ¤í„°", "ì—­í•™ ê´€ê³„", "ë³€í™”ì˜ ë‹¬ì¸"],
            "í–‰ìš´": ["í–‰ìš´ì˜ ë™ì „", "ë„ë°•ê¾¼ì˜ ì‹¬ë¦¬", "ìš´ëª… ì¡°ì‘"],
            "ì™„ë²½": ["ì™„ë²½ì£¼ì˜ì", "ì ˆëŒ€ ë²•ì¹™", "í˜„ì‹¤ í¸ì§‘"]
        }
        
        # ì‚¬ìš©ì íƒœê·¸ì— ë§ëŠ” íŒ¨ì‹œë¸Œ ìˆ˜ì§‘
        for tag in user_tags:
            if tag in tag_to_passives:
                for passive_name in tag_to_passives[tag]:
                    matching_passive = next((p for p in all_passives if p['name'] == passive_name), None)
                    if matching_passive and matching_passive not in recommended:
                        recommended.append(matching_passive)
        
        # ê¸°ë³¸ íŒ¨ì‹œë¸Œë“¤ë„ ì¼ë¶€ ì¶”ê°€ (ì½”ìŠ¤íŠ¸ê°€ ë‚®ì€ ê²ƒë“¤)
        basic_passives = ["ì²«ê±¸ìŒì˜ ìš©ê¸°", "ì ˆì•½ ì •ì‹ ", "ëª¨í—˜ê°€ì˜ ì§ê°"]
        for name in basic_passives:
            passive = next((p for p in all_passives if p['name'] == name), None)
            if passive and passive not in recommended:
                recommended.append(passive)
        
        return recommended[:10]  # ìµœëŒ€ 10ê°œ ì¶”ì²œ
    
    def _analyze_question_based_party(self, party: List[Character], user_tags: List[str]):
        """ì§ˆë¬¸ ê¸°ë°˜ íŒŒí‹° ë¶„ì„ ë° í‘œì‹œ"""
        print(f"\n{GREEN}=== ì§ˆë¬¸ ê¸°ë°˜ ë§ì¶¤ íŒŒí‹° ==={RESET}")
        
        # ì‚¬ìš©ì ì„±í–¥ ë¶„ì„ í‘œì‹œ
        print(f"{MAGENTA}ğŸ¯ ë‹¹ì‹ ì˜ í”Œë ˆì´ ì„±í–¥:{RESET}")
        tag_counts = {}
        for tag in user_tags:
            tag_counts[tag] = tag_counts.get(tag, 0) + 1
        
        # ìƒìœ„ íƒœê·¸ë“¤ì„ í•œêµ­ì–´ë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
        tag_translations = {
            "ì†ë„": "ë¹ ë¥¸ ì „íˆ¬", "ë”œëŸ¬": "ê³µê²© ì¤‘ì‹¬", "ë°©ì–´": "ì•ˆì • ì¤‘ì‹¬", "ë§ˆë²•": "ë§ˆë²• ì„ í˜¸",
            "ì„œí¬í„°": "ì§€ì› ì„ í˜¸", "íŠ¹ìˆ˜": "ë…íŠ¹í•œ ê¸°ë¯¹", "ìŠ¤íƒ": "ì „ëµì  ê´€ë¦¬", "íŒ€ì›Œí¬": "í˜‘ë ¥ ì¤‘ì‹œ",
            "ê³µê²©ì ": "ì ê·¹ì  ì„±í–¥", "ì‹ ì¤‘": "ì‹ ì¤‘í•œ ì„±í–¥", "ë¶„ì„": "ë¶„ì„ì  ì‚¬ê³ ", "ìƒì¡´": "ìƒì¡´ ì¤‘ì‹œ"
        }
        
        top_tags = sorted(tag_counts.items(), key=lambda x: x[1], reverse=True)[:4]
        for tag, count in top_tags:
            korean_tag = tag_translations.get(tag, tag)
            print(f"  âœ¨ {korean_tag} ({count}íšŒ ì„ íƒ)")
        
        print()
        
        # íŒŒí‹° êµ¬ì„± í‘œì‹œ
        for i, character in enumerate(party, 1):
            role = self._get_character_role(character.character_class)
            passives = [trait.name for trait in character.active_traits]
            
            # ì§ì—… ê¸°ë¯¹ ì •ë³´ ì¶”ê°€
            mechanic_info = ""
            if character.character_class in self.CLASS_MECHANICS:
                mechanic = self.CLASS_MECHANICS[character.character_class]
                mechanic_info = f" [{mechanic['display']}]"
            
            print(f"{WHITE}{i}. {character.name}{RESET}")
            print(f"   ì§ì—…: {CYAN}{character.character_class}{RESET} ({role}){mechanic_info}")
            print(f"   íŠ¹ì„±: {YELLOW}{', '.join(passives) if passives else 'ì—†ìŒ'}{RESET}")
            print()
        
        # íŒŒí‹° ì‹œë„ˆì§€ ë° ì¶”ì²œ ì´ìœ 
        print(f"{BLUE}ğŸ¯ ì´ íŒŒí‹°ê°€ ì¶”ì²œëœ ì´ìœ :{RESET}")
        
        # ì—­í•  ê· í˜• ë¶„ì„
        roles = self._analyze_roles([c.character_class for c in party])
        balanced_roles = [role for role, count in roles.items() if count > 0]
        if len(balanced_roles) >= 3:
            print(f"  âœ… ê· í˜•ì¡íŒ ì—­í•  êµ¬ì„±: {', '.join(balanced_roles)}")
        
        # ì‹œë„ˆì§€ í™•ì¸
        synergies = self._check_synergies(party)
        if synergies:
            print(f"  âœ¨ íŒŒí‹° ì‹œë„ˆì§€ ë°œê²¬:")
            for synergy in synergies[:2]:  # ìµœëŒ€ 2ê°œë§Œ í‘œì‹œ
                print(f"    â€¢ {synergy}")
        
        # í”Œë ˆì´ ìŠ¤íƒ€ì¼ ë§¤ì¹­
        style_match = []
        if "ê³µê²©ì " in user_tags or "ë”œëŸ¬" in user_tags:
            attackers = [c for c in party if self._get_character_role(c.character_class) in ["ë”œëŸ¬", "í•˜ì´ë¸Œë¦¬ë“œ"]]
            if len(attackers) >= 2:
                style_match.append("ê³µê²©ì ì¸ í”Œë ˆì´ ìŠ¤íƒ€ì¼ì— ì í•©")
        
        if "ë°©ì–´" in user_tags or "ìƒì¡´" in user_tags:
            defenders = [c for c in party if self._get_character_role(c.character_class) in ["íƒ±ì»¤", "ì„œí¬í„°"]]
            if len(defenders) >= 2:
                style_match.append("ì•ˆì •ì ì¸ í”Œë ˆì´ ìŠ¤íƒ€ì¼ì— ì í•©")
        
        if "ë§ˆë²•" in user_tags:
            mages = [c for c in party if self._get_character_role(c.character_class) == "ë§ˆë²•ì‚¬"]
            if mages:
                style_match.append("ë§ˆë²• ì¤‘ì‹¬ í”Œë ˆì´ì— ìµœì í™”")
        
        for match in style_match:
            print(f"  ğŸ® {match}")
        
        print(f"\n{GREEN}ë§ì¶¤í˜• íŒŒí‹° êµ¬ì„± ì™„ë£Œ! ğŸ‰{RESET}")
    
    def display_class_mechanics(self, class_name: str):
        """ì§ì—…ë³„ ê³ ìœ  ê¸°ë¯¹ í‘œì‹œ"""
        if class_name not in self.CLASS_MECHANICS:
            return
        
        mechanic = self.CLASS_MECHANICS[class_name]
        print(f"\n{CYAN}ğŸ”§ {class_name} ê³ ìœ  ê¸°ë¯¹:{RESET}")
        print(f"  íƒ€ì…: {YELLOW}{mechanic['type']}{RESET}")
        print(f"  í‘œì‹œëª…: {GREEN}{mechanic['display']}{RESET}")
        print(f"  ìµœëŒ€ê°’: {BLUE}{mechanic['max']}{RESET}")
        print(f"  ì„¤ëª…: {WHITE}{mechanic['description']}{RESET}")

    def create_balanced_party(self, user_selected: List[str] = None, party_size: int = 4, auto_select_traits: bool = False) -> List[Character]:
        """ë°¸ëŸ°ìŠ¤ ì¡íŒ íŒŒí‹° ìƒì„± (ê°œì„ ëœ ë‹¤ì–‘ì„± ì•Œê³ ë¦¬ì¦˜)"""
        if user_selected is None:
            user_selected = []
        
        # ì‚¬ìš©ì ì„ íƒ ì €ì¥
        self.last_user_selection = user_selected.copy()
        
        # ì´ë¦„ ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ì‚¬ìš©ëœ ì´ë¦„ ì´ˆê¸°í™”
        self._used_names = set()
        
        # ì‚¬ìš©ì ì„ íƒ ìºë¦­í„° ê²€ì¦
        validated_selected = []
        for class_name in user_selected:
            if class_name in self.ALL_CLASSES:
                validated_selected.append(class_name)
            else:
                print(f"{YELLOW}ê²½ê³ : '{class_name}'ëŠ” ìœ íš¨í•˜ì§€ ì•Šì€ ì§ì—…ì…ë‹ˆë‹¤.{RESET}")
        
        print(f"\n{CYAN}=== ìë™ íŒŒí‹° êµ¬ì„± ì‹œì‘ ==={RESET}")
        if validated_selected:
            print(f"{GREEN}ì‚¬ìš©ì ì„ íƒ: {', '.join(validated_selected)}{RESET}")
        
        # ë‹¤ì–‘ì„± ë³´ì¥ì„ ìœ„í•œ ë‹¤ì¤‘ ì‹œë„ ì‹œìŠ¤í…œ
        best_party_classes = None
        max_diversity_score = -1
        
        # ìµœëŒ€ 5ë²ˆ ì‹œë„í•˜ì—¬ ê°€ì¥ ë‹¤ì–‘í•œ ì¡°í•© ì„ íƒ
        for attempt in range(5):
            try_party_classes = self._select_party_classes(validated_selected, party_size)
            diversity_score = self._calculate_diversity_score(try_party_classes)
            
            if diversity_score > max_diversity_score:
                max_diversity_score = diversity_score
                best_party_classes = try_party_classes
            
            # ì™„ë²½í•œ ë‹¤ì–‘ì„±(ëª¨ë‘ ë‹¤ë¥¸ ì§ì—…)ì´ë©´ ì¦‰ì‹œ ì„ íƒ
            if len(set(try_party_classes)) == len(try_party_classes):
                best_party_classes = try_party_classes
                break
        
        party_classes = best_party_classes
        print(f"{BLUE}ë‹¤ì–‘ì„± ì ìˆ˜: {max_diversity_score}/100{RESET}")
        
        party_members = []
        
        for i, class_name in enumerate(party_classes):
            character = self._create_character(class_name, i + 1)
            
            # ì´ë¦„ ì»¤ìŠ¤í„°ë§ˆì´ì§• (auto_select_traitsê°€ Falseì¸ ê²½ìš°)
            if not auto_select_traits:
                self._allow_name_customization(character)
            
            # íŠ¹ì„± ì„ íƒ ì²˜ë¦¬
            if auto_select_traits:
                self._auto_select_passives(character)
            else:
                # ì‚¬ìš©ìê°€ ì§ì ‘ íŠ¹ì„± ì„ íƒ
                self._manual_select_passives(character)
                
            # ì‹œì‘ ì¥ë¹„ ì œê³µ
            self._provide_starting_equipment(character)
            
            party_members.append(character)
        
        # íŒŒí‹° ë¶„ì„ ë° ì‹œë„ˆì§€ í™•ì¸
        self._analyze_party(party_members)
        
        # Easy Character Creatorì—ì„œ í™•ì¸ì„ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ìƒëµ
        # self._offer_regeneration_option(party_members)
        
        return party_members
    
    def regenerate_party(self, party_size: int = 4) -> List[Character]:
        """íŒŒí‹° ì¬ìƒì„± (ë§ˆì§€ë§‰ ì‚¬ìš©ì ì„ íƒ ìœ ì§€)"""
        print(f"\n{CYAN}ğŸ”„ íŒŒí‹° ì¬ìƒì„± ì¤‘...{RESET}")
        return self.create_balanced_party(self.last_user_selection, party_size)
    
    def _offer_regeneration_option(self, current_party: List[Character]):
        """íŒŒí‹° ì¬ìƒì„± ì˜µì…˜ ì œê³µ"""
        print(f"\n{YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”{RESET}")
        print(f"{WHITE}íŒŒí‹°ê°€ ë§ˆìŒì— ë“œì‹œë‚˜ìš”?{RESET}")
        print(f"{GREEN}âœ… Enter: ì´ íŒŒí‹°ë¡œ ì§„í–‰{RESET}")
        print(f"{CYAN}ğŸ”„ R: íŒŒí‹° ì¬ìƒì„±{RESET}")
        print(f"{RED}âŒ Q: ì¢…ë£Œ{RESET}")
        print(f"{YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”{RESET}")
        
        while True:
            try:
                choice = self.keyboard.get_key().lower()
                
                if choice == '' or choice == 'enter' or choice == '\r':
                    print(f"{GREEN}âœ… íŒŒí‹° í™•ì •!{RESET}")
                    break
                elif choice == 'r':
                    regenerated_party = self.regenerate_party()
                    return regenerated_party
                elif choice == 'q':
                    print(f"{RED}âŒ íŒŒí‹° ìƒì„± ì·¨ì†Œ{RESET}")
                    return None
                else:
                    print(f"{RED}ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤. Enter, R, ë˜ëŠ” Që¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.{RESET}")
            except KeyboardInterrupt:
                print(f"\n{RED}âŒ íŒŒí‹° ìƒì„± ì·¨ì†Œ{RESET}")
                return None
    
    def _select_party_classes(self, user_selected: List[str], party_size: int) -> List[str]:
        """íŒŒí‹° ì§ì—… ì„ íƒ (ë°¸ëŸ°ìŠ¤ ê³ ë ¤ + ë‹¤ì–‘ì„± ê°•í™”)"""
        remaining_slots = party_size - len(user_selected)
        available_classes = [c for c in self.ALL_CLASSES if c not in user_selected]
        
        if remaining_slots <= 0:
            return user_selected[:party_size]
        
        # ğŸ² ë‹¤ì–‘ì„± ê°•í™”: ìì£¼ ì„ íƒë˜ëŠ” ì§ì—…ë“¤ì„ í”¼í•˜ê¸° ìœ„í•œ ê°€ì¤‘ì¹˜ ì¡°ì •
        # ê³ ì •ë˜ëŠ” ì§ì—…ë“¤ (ê¶ìˆ˜, ì•”ì‚´ì, ì‚¬ë¬´ë¼ì´, ë„ì )ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì¤„ì„
        overused_classes = ["ê¶ìˆ˜", "ì•”ì‚´ì", "ì‚¬ë¬´ë¼ì´", "ë„ì "]
        underused_classes = ["ê¸°ê³„ê³µí•™ì", "ë¬´ë‹¹", "ì² í•™ì", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë°”ë“œ", "ëª½í¬", "ë§ˆê²€ì‚¬"]
        
        # í˜„ì¬ íŒŒí‹° ì—­í•  ë¶„ì„
        current_roles = self._analyze_roles(user_selected)
        needed_roles = self._determine_needed_roles(current_roles, remaining_slots)
        
        selected_classes = user_selected.copy()
        
        # í•„ìš”í•œ ì—­í• ì— ë”°ë¼ ìºë¦­í„° ì„ íƒ (ë‹¤ì–‘ì„± ê°€ì¤‘ì¹˜ ì ìš©)
        for role in needed_roles:
            if remaining_slots <= 0:
                break
                
            role_candidates = [c for c in self.ROLE_CLASSES.get(role, []) if c in available_classes]
            
            if role_candidates:
                # ğŸ¯ ë‹¤ì–‘ì„± ê¸°ë°˜ ì„ íƒ: ëœ ì‚¬ìš©ë˜ëŠ” ì§ì—…ì— ë†’ì€ ê°€ì¤‘ì¹˜
                weighted_candidates = []
                for candidate in role_candidates:
                    weight = 1.0  # ê¸°ë³¸ ê°€ì¤‘ì¹˜
                    
                    if candidate in underused_classes:
                        weight *= 3.0  # ëœ ì‚¬ìš©ë˜ëŠ” ì§ì—…ì€ 3ë°° ê°€ì¤‘ì¹˜
                    elif candidate in overused_classes:
                        weight *= 0.3  # ìì£¼ ì‚¬ìš©ë˜ëŠ” ì§ì—…ì€ 30% ê°€ì¤‘ì¹˜
                    
                    # ì‹œë„ˆì§€ë„ ê³ ë ¤í•˜ë˜ ë‹¤ì–‘ì„±ì´ ìš°ì„ 
                    synergy_score = self._calculate_synergy_score(candidate, selected_classes)
                    weight *= (1.0 + synergy_score * 0.2)  # ì‹œë„ˆì§€ëŠ” 20% ë³´ë„ˆìŠ¤ë§Œ
                    
                    weighted_candidates.extend([candidate] * int(weight * 10))
                
                # ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
                if weighted_candidates:
                    best_candidate = random.choice(weighted_candidates)
                else:
                    best_candidate = random.choice(role_candidates)
                    
                selected_classes.append(best_candidate)
                available_classes.remove(best_candidate)
                remaining_slots -= 1
        
        # ë‚¨ì€ ìŠ¬ë¡¯ì€ ë‹¤ì–‘ì„± ìš°ì„  ëœë¤ ì„ íƒ
        while remaining_slots > 0 and available_classes:
            # ë‹¤ì–‘ì„± ê°€ì¤‘ì¹˜ ì ìš©
            weighted_available = []
            for candidate in available_classes:
                weight = 1.0
                if candidate in underused_classes:
                    weight *= 2.5  # ëœ ì‚¬ìš©ë˜ëŠ” ì§ì—… ìš°ì„ 
                elif candidate in overused_classes:
                    weight *= 0.4  # ìì£¼ ì‚¬ìš©ë˜ëŠ” ì§ì—… íšŒí”¼
                weighted_available.extend([candidate] * int(weight * 10))
            
            if weighted_available:
                random_choice = random.choice(weighted_available)
            else:
                random_choice = random.choice(available_classes)
                
            selected_classes.append(random_choice)
            available_classes.remove(random_choice)
            remaining_slots -= 1
        
        return selected_classes
    
    def _calculate_synergy_score(self, candidate: str, current_party: List[str]) -> float:
        """í›„ë³´ ì§ì—…ê³¼ í˜„ì¬ íŒŒí‹° ê°„ì˜ ì‹œë„ˆì§€ ì ìˆ˜ ê³„ì‚°"""
        synergy_score = 0.0
        
        for member in current_party:
            # ì‹œë„ˆì§€ ì¡°í•© í™•ì¸
            synergy_key1 = f"{member} + {candidate}"
            synergy_key2 = f"{candidate} + {member}"
            
            if synergy_key1 in self.SYNERGY_COMBINATIONS:
                synergy_score += 0.5
            elif synergy_key2 in self.SYNERGY_COMBINATIONS:
                synergy_score += 0.5
        
        return synergy_score
    
    def _analyze_roles(self, classes: List[str]) -> Dict[str, int]:
        """í˜„ì¬ íŒŒí‹°ì˜ ì—­í•  ë¶„ì„"""
        role_count = {"íƒ±ì»¤": 0, "ë”œëŸ¬": 0, "ë§ˆë²•ì‚¬": 0, "ì„œí¬í„°": 0, "í•˜ì´ë¸Œë¦¬ë“œ": 0}
        
        for class_name in classes:
            for role, role_classes in self.ROLE_CLASSES.items():
                if class_name in role_classes:
                    role_count[role] += 1
                    break
        
        return role_count
    
    def _determine_needed_roles(self, current_roles: Dict[str, int], remaining_slots: int) -> List[str]:
        """í•„ìš”í•œ ì—­í•  ê²°ì • (ë‹¤ì–‘í•œ ì¡°í•©ì„ ìœ„í•œ ê°œì„ ëœ ë¡œì§)"""
        needed_roles = []
        
        # íŒŒí‹° êµ¬ì„± íŒ¨í„´ë“¤ ì •ì˜ (4ì¸ íŒŒí‹° ê¸°ì¤€)
        composition_patterns = [
            # ë°¸ëŸ°ìŠ¤í˜• (í´ë˜ì‹)
            ["íƒ±ì»¤", "ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            ["íƒ±ì»¤", "ë”œëŸ¬", "ì„œí¬í„°", "ì„œí¬í„°"],
            
            # ê³µê²©í˜• (ë”œëŸ¬ ì¤‘ì‹¬)
            ["ë”œëŸ¬", "ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            ["ë”œëŸ¬", "ë”œëŸ¬", "ë”œëŸ¬", "ì„œí¬í„°"],
            ["ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            
            # ë§ˆë²•í˜• (ë§ˆë²•ì‚¬ ì¤‘ì‹¬)
            ["ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            ["ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ë”œëŸ¬", "ì„œí¬í„°"],
            ["íƒ±ì»¤", "ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            
            # ì„œí¬í„°í˜• (ì§€ì› ì¤‘ì‹¬)
            ["íƒ±ì»¤", "ë”œëŸ¬", "ì„œí¬í„°", "ì„œí¬í„°"],
            ["ë§ˆë²•ì‚¬", "ì„œí¬í„°", "ì„œí¬í„°", "ì„œí¬í„°"],
            
            # í•˜ì´ë¸Œë¦¬ë“œí˜• (íŠ¹ìˆ˜ ì¡°í•©)
            ["í•˜ì´ë¸Œë¦¬ë“œ", "ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            ["íƒ±ì»¤", "í•˜ì´ë¸Œë¦¬ë“œ", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"],
            ["ë”œëŸ¬", "ë”œëŸ¬", "í•˜ì´ë¸Œë¦¬ë“œ", "ì„œí¬í„°"],
            
            # ê·¹í•œí˜• (ë„ì „ì )
            ["íƒ±ì»¤", "íƒ±ì»¤", "ë”œëŸ¬", "ì„œí¬í„°"],
            ["ë”œëŸ¬", "ë”œëŸ¬", "ë”œëŸ¬", "ë”œëŸ¬"],  # ê·¹ë”œíŒŒí‹°
            ["ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬", "ë§ˆë²•ì‚¬"],  # ê·¹ë§ˆíŒŒí‹°
        ]
        
        # í˜„ì¬ íŒŒí‹° í¬ê¸°ì— ë”°ë¼ íŒ¨í„´ ì„ íƒ
        total_party_size = sum(current_roles.values()) + remaining_slots
        
        # ëœë¤í•˜ê²Œ êµ¬ì„± íŒ¨í„´ ì„ íƒ
        selected_pattern = random.choice(composition_patterns)
        
        # í˜„ì¬ íŒŒí‹°ì—ì„œ ë¶€ì¡±í•œ ì—­í• ë“¤ ê³„ì‚°
        for role in selected_pattern:
            if len(needed_roles) >= remaining_slots:
                break
                
            current_count = current_roles.get(role, 0)
            needed_count = selected_pattern.count(role)
            already_added = needed_roles.count(role)
            
            if current_count + already_added < needed_count:
                needed_roles.append(role)
        
        # ë‚¨ì€ ìŠ¬ë¡¯ì´ ìˆìœ¼ë©´ ì™„ì „ ëœë¤ ì„ íƒ (20% í™•ë¥ ë¡œ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ì¡°í•©)
        while len(needed_roles) < remaining_slots:
            if random.random() < 0.2:  # 20% í™•ë¥ ë¡œ ì™„ì „ ëœë¤
                all_roles = ["íƒ±ì»¤", "ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°", "í•˜ì´ë¸Œë¦¬ë“œ"]
                needed_roles.append(random.choice(all_roles))
            else:
                # ë¶€ì¡±í•œ í•µì‹¬ ì—­í•  ìš°ì„  ì¶”ê°€
                missing_core_roles = []
                if current_roles["íƒ±ì»¤"] == 0 and "íƒ±ì»¤" not in needed_roles:
                    missing_core_roles.append("íƒ±ì»¤")
                if current_roles["ì„œí¬í„°"] == 0 and "ì„œí¬í„°" not in needed_roles:
                    missing_core_roles.append("ì„œí¬í„°")
                if current_roles["ë”œëŸ¬"] == 0 and "ë”œëŸ¬" not in needed_roles:
                    missing_core_roles.append("ë”œëŸ¬")
                
                if missing_core_roles:
                    needed_roles.append(random.choice(missing_core_roles))
                else:
                    # ëª¨ë“  í•µì‹¬ ì—­í• ì´ ìˆìœ¼ë©´ ëœë¤ ì¶”ê°€
                    preferred_roles = ["ë”œëŸ¬", "ë§ˆë²•ì‚¬", "ì„œí¬í„°"]  # í•˜ì´ë¸Œë¦¬ë“œëŠ” í¬ì†Œì„± ìœ ì§€
                    needed_roles.append(random.choice(preferred_roles))
        
        return needed_roles[:remaining_slots]
    
    def _select_best_candidate(self, candidates: List[str], current_party: List[str]) -> str:
        """ì‹œë„ˆì§€ì™€ ë‹¤ì–‘ì„±ì„ ê³ ë ¤í•œ ìµœì  í›„ë³´ ì„ íƒ (ê°œì„ ëœ ì•Œê³ ë¦¬ì¦˜)"""
        if not candidates:
            return None
            
        # 30% í™•ë¥ ë¡œ ì™„ì „ ëœë¤ ì„ íƒ (ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥ì„± ì¦ê°€)
        if random.random() < 0.3:
            return random.choice(candidates)
        
        synergy_scores = {}
        
        for candidate in candidates:
            score = 0
            
            # ì‹œë„ˆì§€ í™•ì¸ (ê°€ì¤‘ì¹˜ ê°ì†Œ)
            for party_member in current_party:
                synergy_key1 = f"{party_member} + {candidate}"
                synergy_key2 = f"{candidate} + {party_member}"
                
                if synergy_key1 in self.SYNERGY_COMBINATIONS or synergy_key2 in self.SYNERGY_COMBINATIONS:
                    score += 5  # 10ì—ì„œ 5ë¡œ ê°ì†Œ
            
            # ë‹¤ì–‘ì„± ë³´ë„ˆìŠ¤ ê°•í™” (ê°™ì€ ì§ì—…ì´ ì—†ìœ¼ë©´ í° ë³´ë„ˆìŠ¤)
            if candidate not in current_party:
                score += 15  # 5ì—ì„œ 15ë¡œ ì¦ê°€
            
            # í¬ì†Œ ì§ì—… ë³´ë„ˆìŠ¤ (í•˜ì´ë¸Œë¦¬ë“œ ì§ì—…ë“¤)
            rare_classes = ["ì•”ì‚´ì", "í•´ì ", "ì‚¬ë¬´ë¼ì´", "ë“œë£¨ì´ë“œ", "ì² í•™ì", 
                           "ê²€íˆ¬ì‚¬", "ê¸°ì‚¬", "ì‹ ê´€", "ê´‘ì „ì‚¬"]
            if candidate in rare_classes:
                score += 10
            
            # ê· í˜• ë³´ë„ˆìŠ¤ - íŠ¹ì • ì—­í• ì´ ë„ˆë¬´ ë§ìœ¼ë©´ í˜ë„í‹°
            candidate_role = None
            for role, classes in self.ROLE_CLASSES.items():
                if candidate in classes:
                    candidate_role = role
                    break
            
            if candidate_role:
                role_count = sum(1 for member in current_party 
                               for role, classes in self.ROLE_CLASSES.items()
                               if member in classes and role == candidate_role)
                
                # ê°™ì€ ì—­í• ì´ 2ëª… ì´ìƒì´ë©´ í˜ë„í‹°
                if role_count >= 2:
                    score -= 8
                elif role_count >= 1:
                    score -= 3
            
            synergy_scores[candidate] = score
        
        # ìƒìœ„ 50% í›„ë³´êµ°ì—ì„œ ëœë¤ ì„ íƒ (ë‹¤ì–‘ì„± ì¦ê°€)
        sorted_candidates = sorted(synergy_scores.items(), key=lambda x: x[1], reverse=True)
        top_half_count = max(1, len(sorted_candidates) // 2)
        top_candidates = [candidate for candidate, score in sorted_candidates[:top_half_count]]
        
        return random.choice(top_candidates)
    
    def _create_character(self, class_name: str, index: int) -> Character:
        """ìºë¦­í„° ìƒì„±"""
        # ëŒ€í­ í™•ì¥ëœ ìºë¦­í„° ì´ë¦„ í’€ (300ê°œ ì´ìƒ)
        character_names = [
            # ë‚¨ì„± ì´ë¦„ (150ê°œ)
            "ì•„ë¦¬ìš°ìŠ¤", "ë°œë Œíƒ€ì¸", "ê°€ë¸Œë¦¬ì—˜", "ë¼íŒŒì—˜", "ì¹´ì´ì €", "ë ˆì˜¤ë‚˜ë¥´ë“œ", "ì„¸ë°”ìŠ¤ì°¬", "ì•Œë ‰ì‚°ë”",
            "ë§‰ì‹œë¬´ìŠ¤", "ì•„ë“œë¦¬ì•ˆ", "ë£¨ì¹´ìŠ¤", "ë‹ˆì½œë¼ìŠ¤", "ë„ë¯¸ë‹‰", "ë¹ˆì„¼íŠ¸", "ì—ë°€ë¦¬ì˜¤", "ë§ˆë¥´ì½”",
            "í´ë¼ìš°ë””ìš°ìŠ¤", "ì˜¤ê±°ìŠ¤íŠ¸", "ë°”ì‹¤ë¦¬ìš°ìŠ¤", "ì´ê·¸ë‹ˆìŠ¤", "í ë¦­ìŠ¤", "ë¼ì´ì–¸", "ì—ë¦­",
            "ë§ˆí‹´", "ì—˜ë¦¬ì•„ìŠ¤", "ë‹¤ë¯¸ì•ˆ", "ìœ¨ë¦¬ì•ˆ", "ì¹´ë¥¼ë¡œìŠ¤", "ë””ì—ê³ ", "íŒŒë¸”ë¡œ", "í”„ë€ì‹œìŠ¤",
            "ë¡œë“œë¦¬ê³ ", "ì•ˆí† ë‹ˆì˜¤", "í˜ë“œë¡œ", "ë¯¸êµ¬ì—˜", "í˜¸ì„¸", "ë£¨ì´ìŠ¤", "í˜ë¥´ë‚œë„", "ì• ë“œì›Œë“œ",
            "ë¼ëª¬", "í˜¸ë¥´í—¤", "ì¹´ë¥¼ë¡œìŠ¤", "ë§ˆëˆ„ì—˜", "í”„ë‘í¬", "ì˜¬ë¦¬ë²„", "í•´ë¦¬", "ì­", "ìœŒë¦¬ì—„",
            "ì œì„ìŠ¤", "ì°°ìŠ¤", "ë¡œë²„íŠ¸", "ë§ˆì´í´", "ë°ì´ë¹„ë“œ", "ë¦¬ì²˜ë“œ", "ì¡°ì…‰", "í† ë¨¸ìŠ¤", "í¬ë¦¬ìŠ¤í† í¼",
            "ë§¤íŠ¸", "ì•¤ì†Œë‹ˆ", "ë§ˆí¬", "ë„ë„ë“œ", "ìŠ¤í‹°ë¸", "í´", "ì•¤ë“œë¥˜", "ì¡°ìŠˆì•„", "ì¼€ë„¤ìŠ¤", "ì¼€ë¹ˆ",
            "ë¸Œë¼ì´ì–¸", "ì¡°ì§€", "ì—ë“œì›Œë“œ", "ë¡œë„ë“œ", "í‹°ëª¨ì‹œ", "ì œì´ìŠ¨", "ì œí”„ë¦¬", "ë¼ì´ì–¸", "ì œì´ì½¥",
            "ê²Œë¦¬", "ë‹ˆì½œë¼ìŠ¤", "ì—ë¦­", "ì¡°ë‚˜ë‹¨", "ìŠ¤í‹°ë¸", "ë˜ë¦¬", "ì €ìŠ¤í‹´", "ìŠ¤ì½§", "ë¸Œëœë“ ", "ë²¤ìë¯¼",
            "ì‚¬ë¬´ì—˜", "ê·¸ë ˆê³ ë¦¬", "ì•Œë ‰ì‚°ë”", "íŒ¨íŠ¸ë¦­", "ì­", "ë°ë‹ˆìŠ¤", "ì œë¦¬", "íƒ€ì¼ëŸ¬", "ì• ëŸ°",
            "í˜¸ì„¸", "í—¨ë¦¬", "ë”ê¸€ëŸ¬ìŠ¤", "ë„¤ì´ì„ ", "í”¼í„°", "ì­ìŠ¨", "ë…¸ì•„", "ì´ë‹¨", "ë£¨ì¹´ìŠ¤", "ë©”ì´ìŠ¨",
            "ë¡œê±´", "ì œì´ì½¥", "ìœŒë¦¬ì—„", "ì—˜ë¦¬ì•¼", "ì›¨ì¸", "ì¹¼ë ™", "ë¼ì´ì–¸", "ë‹ˆì½œë¼ìŠ¤", "ì¡°ë˜",
            "ë¡œë²„íŠ¸", "ê·¸ë ˆì´ìŠ¨", "í—Œí„°", "ì—ì´ë“ ", "ì¹´ë©”ë¡ ", "ì½”ë„ˆ", "ì‚°í‹°ì•„ê³ ", "ì¹¼ë ™", "ë„¤ì´ì„ ",
            "ì´ì‚¬ì´ì•¼", "ì°°ë¦¬", "ì´ë°˜", "ì˜¤ì›¬", "ë£¨í¬", "ë”œëŸ°", "ì­ìŠ¨", "ê°€ë¹ˆ", "ë°ì´ë¹„ë“œ", "ì½œíŠ¼",
            "ì•¤ë“œë¥˜", "ë§¥ìŠ¤", "ë¼ì´ì–¸", "ë¸Œë ˆì´ë“ ", "í† ë¨¸ìŠ¤", "ì¹´í„°", "ë‹¤ë‹ˆì—˜", "ë§ˆì´í´", "ì•„ë‹´",
            "ì—˜ë¼ì´", "ë²¤ìë¯¼", "í•€", "ì½”ë”˜", "íŠ¸ë¦¬ìŠ¤íƒ„", "ë¡œë„Œ", "ë¸”ë ˆì´í¬", "ë¸Œë¡œë””", "ë°í´ë€",
            "ìˆ€", "ë¦¬ì•”", "ë£¨ì¹´", "ì œì„ìŠ¨", "ì¹´ì¼", "ë¸Œëœë“ ", "ì•Œë ‰ìŠ¤", "ìì´ë“ ", "ìë¹„ì—ë¥´","í…Œì˜¤",
            "ë„ë¯¸ë‹‰", "ë°ë¯¸íŠ¸ë¦¬","ì—ì´ìŠ¤", "ë‹ˆí‚¤íƒ€", "ë¸”ë¼ë””ë¯¸ë¥´", "ì•Œë ‰ì„¸ì´", "ì´ë°˜", "ì•ˆí†¤", "ì˜¬ë ‰",
            "ì„¸ë¥´ê²", "ë¹…í„°", "ë¡œë§Œ", "íŒŒë²¨", "ë…¹í‹°ìŠ¤", "ì•„ë¥´í…œ", "ì½˜ìŠ¤íƒ„í‹´", "ë°œë Œí‹´", "ë“œë¯¸íŠ¸ë¦¬","í‹°ë”","í´ë¼ìš°ë“œ","í”„ë¡¬í”„í† ","ê·¸ë¦¼ë‹ˆë¥´","ì‹œìŠ¤","ëœìŠ¬ë¡¯",
            
            # ì—¬ì„± ì´ë¦„ (150ê°œ)
            "ì•„ë¦¬ì•„", "ì…€ë ˆìŠ¤íŠ¸","ìœ ë‚˜", "ì´ì‚¬ë²¨ë¼", "ë°œë ˆë¦¬ì•„", "ì„¸ë¼í”¼ë‚˜", "ì•„ë“œë¦¬ì•„ë‚˜", "ë°€ë¦¬ì•„", "ë¹„ë¹„ì•ˆ", "í´ë¼ë¼","ë¹„ë¼","ìœ ì—˜",
            "ì—ë°€ë¦¬ì•„", "ë£¨ì‹œì•„", "ì†Œí”¼ì•„", "ì˜¬ë¦¬ë¹„ì•„", "ë‚˜íƒˆë¦¬ì•„", "ì¹´ë°€ë¼", "ë ˆì˜¤ë‹ˆ", "ë¯¸ë¦¬ì•”",
            "ë¡œì‚¬", "ì—ìŠ¤í…”ë¼", "ë°”ì´ì˜¬ë ›", "ìƒ¬ë¡¯", "ë² ì•„íŠ¸ë¦¬ì²´", "ì¹´íƒ€ë¦¬ë‚˜", "ë ˆë² ì¹´", "ì—˜ë ˆë‚˜",
            "ë§ˆë¦¬ì•„", "ì•ˆë‚˜", "ë£¨ë‚˜", "ì‹œì—ë¼", "ë‹ˆë‚˜", "ì—ë°”", "ë¦´ë¦¬ì•ˆ", "ë¡œë Œ", "ê·¸ë ˆì´ìŠ¤",
            "ì—ë°€ë¦¬", "í•œë‚˜", "ì— ë§ˆ", "ë§¤ë””ìŠ¨", "ì• ìŠë¦¬", "ì‚¬ë¼", "ë¸Œë¦¬íŠ¸ë‹ˆ", "ì‚¬ë§Œë‹¤", "ì œì‹œì¹´",
            "ì•„ë§Œë‹¤", "ìŠ¤í…ŒíŒŒë‹ˆ", "ë‹ˆì½œ", "ë©œë¦¬ì‚¬", "ë°ë³´ë¼", "ë ˆì´ì²¼", "ìºì„œë¦°", "ì—˜ë¦¬ìë² ìŠ¤", "í•´ë”",
            "í‹°íŒŒë‹ˆ", "ì—ì´ë¯¸", "ì¤„ë¦¬", "ì¡°ì´ìŠ¤", "ë¹…í† ë¦¬ì•„", "ì¼ˆë¦¬", "í¬ë¦¬ìŠ¤í‹°ë‚˜", "ì¡°ì•ˆ", "ì´ë¸”ë¦°",
            "ë¦°ë‹¤", "ë°”ë°”ë¼", "ì—˜ë Œ", "ìºëŸ´", "ì‚°ë“œë¼", "ë„ë‚˜", "ë£¨ìŠ¤", "ìƒ¤ë¡ ", "ë¯¸ì…¸", "ë¡œë¼",
            "ì—ë°€ë¦¬", "ì¹¼ë¼", "ë ˆë² ì¹´", "ìŠ¤í…ŒíŒŒë‹ˆ", "ìºë¡¤ë¼ì¸", "ì—˜ë¦¬", "ì œë‚˜", "ë¸Œë£©", "ì¼€ì´íŠ¸",
            "ì‚¬ë°”ë‚˜", "ì œì‹œì¹´", "í…Œì¼ëŸ¬", "í‚´ë²Œë¦¬", "ë°ì´ì§€", "í•˜ì´ë””", "ê°€ë¸Œë¦¬ì—˜ë¼", "ë‹ˆí‚¤",
            "ë¡œë¦°", "ì…¸ë¦¬", "ë ˆìŠ¬ë¦¬", "ì—ë¦¬ì¹´", "ì¹´ì¼ë¦°", "ì• ë‚˜", "ì½”íŠ¸ë‹ˆ", "ë£¨ë¹„", "ì—ë°”",
            "ë©”ê°„", "ì•Œë ‰ì‹œìŠ¤", "ì†Œí”¼ì•„", "í´ë¡œì—", "ì´ì‚¬ë²¨", "ì—ì´ë°”", "ë°€ë¼", "ì•„ë¦¬ì•„ë‚˜",
            "ë¼ì¼ë¼", "ë¯¸ì•„", "ì—ë§ˆ", "ì•„ë“œë¦¬ì•„ë‚˜", "ì•Œë¦¬", "ë¼ì¼ë¦¬", "ìºë°€ë¼", "í´ë ˆì–´", "ë¹…í† ë¦¬ì•„",
            "ì—˜ë¦¬ì•„ë‚˜", "ë‚˜ì˜¤ë¯¸", "ì—˜ë ˆë‚˜", "ë„¤ì´íƒˆë¦¬", "í—¤ì¼ë¦¬", "ë¸Œë£¨í´ë¦°", "ë¡œë Œ", "ì•¨ë¦¬ìŠ¨",
            "ê°€ë¸Œë¦¬ì—˜ë¼", "ì„¸ë¼", "ììŠ¤ë¯¼", "ë§ˆì•¼", "ì‚¬ë§Œë‹¤", "í˜ë„¬ë¡œí˜", "ì˜¤ë¥¼ë¦¬", "ë°œë ˆë¦¬ì•„",
            "ë°”ì´ì˜¬ë ›", "ìŠ¤ì¹´ë¥¼ë¦¿", "ì• ë‚˜ìŠ¤íƒ€ìƒ¤", "ë² ë¡œë‹ˆì¹´", "í…Œë ˆì‚¬", "ì•¤ì ¤ë¼", "ì¹´ë¥´ë©˜", "ëª°ë¦¬",
            "ì…¸ë¦¬", "ë ˆì´ì²¼", "ë‹ˆì½œ", "ì›¬ë””", "ë¦¬ì‚¬", "í‚´ë²Œë¦¬", "ë„ë‚˜", "ì•„ë‹ˆíƒ€", "ë¦¬ë¹„",
            "ì•Œë¦¬ì‹œì•„", "ì•Œë ‰ì‚°ë“œë¼", "í‚¤ì•„ë¼", "ì¡°ì•„ë‚˜", "ë§ˆë¦¬ì‚¬", "ì¹´ë Œ", "ìŠ¤í…Œì´ì‹œ", "ë‹¤ì´ì• ë‚˜",
            "ë¡œì¦ˆ", "ì´ì†”ë°", "ê¸°ë„¤ë¹„ì–´", "ëª¨ë¥´ê°€ë‚˜", "ì„¸ë¼í”¼ë‚˜", "ì•„ë¥´í…Œë¯¸ìŠ¤", "ì•„í…Œë‚˜", "í—¤ë¼",
            "ì•„í”„ë¡œë””í…Œ", "í—¤ìŠ¤í‹°ì•„", "ë°ë©”í…Œë¥´", "í ë ˆ", "í”„ë ˆì´ì•¼", "ì´ë‘ë‚˜", "ë¸Œë£¬íë°", "ë°œí‚¤ë¦¬",
            "í‚¤ë¥´ì¼€", "ì¹´ì‚°ë“œë¼", "ì•ˆë“œë¡œë©”ë‹¤", "í˜ë„¬ë¡œí˜", "í—¬ë Œ", "í´ë ˆì˜¤íŒŒíŠ¸ë¼", "ì´ì‹œìŠ¤", "ë„¤í˜ë¥´í‹°í‹°",
            "ì„¸ë¼í•Œ", "ìš°ë¦¬ì—˜", "ê°€ë¸Œë¦¬ì—˜ë¼", "ë¯¸ì¹´ì—˜ë¼", "ë¼íŒŒì—˜ë¼", "ì•„ë¦¬ì—˜", "ì ¤ë‹¤", "ì„¸ë ˆë‚˜",
            "íŒ¬ë„ë¼", "í¬ì—ë² ", "ì…€ë ˆë„¤", "í—¤ì¹´í…Œ", "ë‹˜í”„", "ì˜¤ë¡œë¼", "ë£¨ë‚˜", "ìŠ¤í…”ë¼", "ë…¸ë°”",
            "ë² ê°€", "ì•ˆë“œë¡œë©”ë‹¤", "ì¹´ì‹œì˜¤í˜ì•„", "ë¼ì´ë¼", "ì•Œíƒ€ì´ë¥´", "ë²¨ë¼íŠ¸ë¦­ìŠ¤", "ë¦¬ê²”", "ì‹œë¦¬ìš°ìŠ¤",
            "í”„ë¡œí‚¤ì˜¨", "ì•„í¬íˆ¬ë£¨ìŠ¤", "ìŠ¤í”¼ì¹´", "ì•Œë°ë°”ë€", "ì¹´í ë¼", "í´ë£©ìŠ¤", "ë ˆêµ´ë£¨ìŠ¤", "ì•ˆíƒ€ë ˆìŠ¤", "ì˜¤ì¦ˆ","ì½”ë¦°"
        ]
        
        # ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ì´ë¦„ ì„ íƒ
        available_names = [name for name in character_names if name not in self._used_names]
        if not available_names:
            # ëª¨ë“  ì´ë¦„ì´ ì‚¬ìš©ë˜ì—ˆìœ¼ë©´ ì´ˆê¸°í™”
            self._used_names.clear()
            available_names = character_names
        
        name = random.choice(available_names)
        self._used_names.add(name)
        
        # ì§ì—…ë³„ ê¸°ë³¸ ìŠ¤íƒ¯ (ë ˆë²¨ 10 ê¸°ì¤€)
        base_stats = self._get_class_base_stats(class_name)
        
        character = Character(
            name=name,
            character_class=class_name,
            max_hp=base_stats["hp"],
            physical_attack=base_stats["physical_attack"],
            magic_attack=base_stats["magic_attack"],
            physical_defense=base_stats["physical_defense"],
            magic_defense=base_stats["magic_defense"],
            speed=base_stats["speed"]
        )
        
        # ë ˆë²¨ 1ë¡œ ì„¤ì •
        character.level = 1
        
        return character
    
    def _get_class_base_stats(self, class_name: str) -> Dict[str, int]:
        """ì§ì—…ë³„ ê¸°ë³¸ ìŠ¤íƒ¯ (ê³ ì •ê°’ìœ¼ë¡œ ë³€ê²½)"""
        # ì§ì—…ë³„ ê³ ì • ìŠ¤íƒ¯ ì •ì˜ (ë ˆë²¨ 10 ê¸°ì¤€)
        fixed_stats = {
            "ì „ì‚¬": {"hp": 216, "physical_attack": 75, "magic_attack": 43, "physical_defense": 63, "magic_defense": 48, "speed": 56},
            "ì•„í¬ë©”ì´ì§€": {"hp": 121, "physical_attack": 43, "magic_attack": 78, "physical_defense": 33, "magic_defense": 67, "speed": 58},
            "ê¶ìˆ˜": {"hp": 164, "physical_attack": 74, "magic_attack": 33, "physical_defense": 44, "magic_defense": 43, "speed": 68},
            "ë„ì ": {"hp": 150, "physical_attack": 64, "magic_attack": 38, "physical_defense": 43, "magic_defense": 49, "speed": 93},
            "ì„±ê¸°ì‚¬": {"hp": 197, "physical_attack": 67, "magic_attack": 38, "physical_defense": 76, "magic_defense": 62, "speed": 43},
            "ì•”í‘ê¸°ì‚¬": {"hp": 189, "physical_attack": 71, "magic_attack": 54, "physical_defense": 58, "magic_defense": 51, "speed": 52},
            "ëª½í¬": {"hp": 172, "physical_attack": 82, "magic_attack": 51, "physical_defense": 59, "magic_defense": 64, "speed": 76},
            "ë°”ë“œ": {"hp": 107, "physical_attack": 43, "magic_attack": 66, "physical_defense": 38, "magic_defense": 58, "speed": 69},
            "ë„¤í¬ë¡œë§¨ì„œ": {"hp": 134, "physical_attack": 44, "magic_attack": 84, "physical_defense": 39, "magic_defense": 74, "speed": 48},
            "ìš©ê¸°ì‚¬": {"hp": 181, "physical_attack": 78, "magic_attack": 62, "physical_defense": 67, "magic_defense": 58, "speed": 61},
            "ê²€ì„±": {"hp": 164, "physical_attack": 83, "magic_attack": 31, "physical_defense": 51, "magic_defense": 47, "speed": 71},
            "ì •ë ¹ìˆ ì‚¬": {"hp": 107, "physical_attack": 49, "magic_attack": 85, "physical_defense": 42, "magic_defense": 69, "speed": 59},
            "ì•”ì‚´ì": {"hp": 134, "physical_attack": 81, "magic_attack": 28, "physical_defense": 34, "magic_defense": 39, "speed": 87},
            "ê¸°ê³„ê³µí•™ì": {"hp": 156, "physical_attack": 63, "magic_attack": 59, "physical_defense": 54, "magic_defense": 48, "speed": 53},
            "ë¬´ë‹¹": {"hp": 121, "physical_attack": 48, "magic_attack": 86, "physical_defense": 44, "magic_defense": 77, "speed": 64},
            "í•´ì ": {"hp": 164, "physical_attack": 74, "magic_attack": 34, "physical_defense": 52, "magic_defense": 41, "speed": 77},
            "ì‚¬ë¬´ë¼ì´": {"hp": 167, "physical_attack": 74, "magic_attack": 45, "physical_defense": 58, "magic_defense": 53, "speed": 67},
            "ë“œë£¨ì´ë“œ": {"hp": 175, "physical_attack": 53, "magic_attack": 81, "physical_defense": 48, "magic_defense": 69, "speed": 59},
            "ì² í•™ì": {"hp": 107, "physical_attack": 38, "magic_attack": 76, "physical_defense": 54, "magic_defense": 86, "speed": 49},
            "ì‹œê°„ìˆ ì‚¬": {"hp": 121, "physical_attack": 54, "magic_attack": 77, "physical_defense": 49, "magic_defense": 64, "speed": 57},
            "ì—°ê¸ˆìˆ ì‚¬": {"hp": 135, "physical_attack": 59, "magic_attack": 72, "physical_defense": 44, "magic_defense": 58, "speed": 54},
            "ê²€íˆ¬ì‚¬": {"hp": 172, "physical_attack": 79, "magic_attack": 41, "physical_defense": 56, "magic_defense": 48, "speed": 64},
            "ê¸°ì‚¬": {"hp": 235, "physical_attack": 79, "magic_attack": 46, "physical_defense": 72, "magic_defense": 54, "speed": 48},
            "ì‹ ê´€": {"hp": 143, "physical_attack": 42, "magic_attack": 79, "physical_defense": 57, "magic_defense": 89, "speed": 52},
            "ë§ˆê²€ì‚¬": {"hp": 164, "physical_attack": 67, "magic_attack": 70, "physical_defense": 54, "magic_defense": 61, "speed": 58},
            "ì°¨ì›ìˆ ì‚¬": {"hp": 84, "physical_attack": 33, "magic_attack": 88, "physical_defense": 28, "magic_defense": 72, "speed": 47},
            "ê´‘ì „ì‚¬": {"hp": 327, "physical_attack": 64, "magic_attack": 13, "physical_defense": 22, "magic_defense": 21, "speed": 74}
        }
        
        return fixed_stats.get(class_name, {
            "hp": 150, "physical_attack": 50, "magic_attack": 50, 
            "physical_defense": 50, "magic_defense": 50, "speed": 50
        })
    
    def _auto_select_passives(self, character: Character):
        """ìë™ íŒ¨ì‹œë¸Œ ì„ íƒ (2ê°œ ê°•ì œ)"""
        if not character.available_traits:
            print(f"  {character.name}: ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        print(f"  {character.name}: ê°œë°œ ëª¨ë“œ = {game_config.are_all_passives_unlocked()}")
        print(f"  {character.name}: ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„± ìˆ˜ = {len(character.available_traits)}")
        
        # ê°œë°œ ëª¨ë“œê°€ ì•„ë‹Œ ê²½ìš° í•´ê¸ˆëœ íŒ¨ì‹œë¸Œë§Œ ì„ íƒ ê°€ëŠ¥
        if not game_config.are_all_passives_unlocked():
            unlocked_traits = character._get_unlocked_traits()
            available_indices = []
            for i, trait in enumerate(character.available_traits):
                if trait.name in unlocked_traits:
                    available_indices.append(i)
            
            # í•´ê¸ˆëœ íŒ¨ì‹œë¸Œê°€ ì—†ìœ¼ë©´ íŒ¨ì‹œë¸Œ ì—†ì´ ì§„í–‰
            if not available_indices:
                character.select_passive_traits([])
                return
            
            # í•´ê¸ˆëœ íŒ¨ì‹œë¸Œ ì¤‘ì—ì„œ 2ê°œ ì„ íƒ (ê°€ëŠ¥í•œ ë§Œí¼)
            num_to_select = min(2, len(available_indices))
            if num_to_select > 0:
                selected_indices = random.sample(available_indices, num_to_select)
                character.select_passive_traits(selected_indices)
            else:
                character.select_passive_traits([])
        else:
            # ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì§ì—… íŠ¹ì„±ì„ ê³ ë ¤í•œ íŒ¨ì‹œë¸Œ ì„ íƒ ë¡œì§
            trait_priorities = self._get_trait_priorities(character.character_class)
            
            # ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬
            sorted_traits = []
            for i, trait in enumerate(character.available_traits):
                priority = trait_priorities.get(trait.name, 0)
                sorted_traits.append((i, trait, priority))  # ì¸ë±ìŠ¤ë„ í•¨ê»˜ ì €ì¥
            
            sorted_traits.sort(key=lambda x: x[2], reverse=True)  # priorityë¡œ ì •ë ¬
            
            # í•­ìƒ 2ê°œ ì„ íƒ (ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ìˆë‹¤ë©´)
            selected_indices = []
            
            if len(sorted_traits) >= 2:
                # ìƒìœ„ 2ê°œ íŠ¹ì„± ì„ íƒ
                selected_indices = [sorted_traits[0][0], sorted_traits[1][0]]
            elif len(sorted_traits) == 1:
                # 1ê°œë§Œ ìˆìœ¼ë©´ 1ê°œë§Œ ì„ íƒ
                selected_indices = [sorted_traits[0][0]]
            
            # íŒ¨ì‹œë¸Œ ì ìš©
            character.select_passive_traits(selected_indices)
    
    def _get_trait_priorities(self, class_name: str) -> Dict[str, int]:
        """ì§ì—…ë³„ íŠ¹ì„± ìš°ì„ ìˆœìœ„ (Phase 1&2 ì‹ ê·œ ì§ì—… í¬í•¨ - 27ê°œ ì§ì—…) - 6ë‹¨ê³„ ì™„ì „ì²´ ì‹œìŠ¤í…œ"""
        priorities = {
            # ì „ì‚¬ê³„ - 6ë‹¨ê³„ ì™„ì „ì²´ ì‹œìŠ¤í…œ ìµœì í™”
            "ì „ì‚¬": {"6ë‹¨ê³„ ì™„ì „ì²´": 10, "ì „ì¥ì˜ ì§€ë°°ì": 9, "ê· í˜•ê°ê°": 8, "ì „íˆ¬ ë³¸ëŠ¥": 7, "ë¶ˆêµ´ì˜ ì˜ì§€": 6},
            "ì„±ê¸°ì‚¬": {"ì‹ ì„±í•œ ë³´í˜¸": 10, "ë¹›ì˜ ì¶•ë³µ": 9, "ì„±ì—­ ë§ˆìŠ¤í„°": 8, "ì‹ ì„± ê°€í˜¸": 7, "ì¹˜ìœ ìˆ ": 6},
            "ì•”í‘ê¸°ì‚¬": {"ìƒëª…ë ¥ ì¡°ì‘": 10, "í¡í˜ˆ ê°•í™”": 9, "ì–´ë‘ ì˜ ê°€í˜¸": 8, "í¡í˜ˆìˆ ": 7, "ì–´ë‘  ì¹œí™”": 6},
            "ê¸°ì‚¬": {"ìˆ˜í˜¸ ë³¸ëŠ¥": 10, "ì˜ë¬´ ë§ˆìŠ¤í„°": 9, "ì°½ìˆ  ë‹¬ì¸": 8, "ê¸°ì‚¬ë„ ì •ì‹ ": 7, "ëª…ì˜ˆ ìˆ˜í˜¸": 6},
            "ìš©ê¸°ì‚¬": {"í™”ì—¼ ê°•í™”": 10, "ìš©ì˜ ìœ ì‚°": 9, "ë“œë˜ê³¤ ë§ˆí¬": 8, "ìš©ì˜ í˜ˆí†µ": 7, "í™”ì—¼ ì¹œí™”": 6},
            "ê²€ì„±": {"ê²€ê¸° ì¡°ì‘": 10, "ê²€ê¸° ì¥ì¸": 9, "ì™„ë²½í•œ ê²€ìˆ ": 8, "ì¼ì„¬ ë‹¬ì¸": 7, "ê²€ì˜ ë„": 6},
            "ê²€íˆ¬ì‚¬": {"íŒ¨ë§ ë§ˆìŠ¤í„°": 10, "íˆ¬ê¸°ì¥ì˜ ê²½í—˜": 9, "ìƒì¡´ ë³¸ëŠ¥": 8, "íˆ¬ì‚¬ì˜ ê¸ì§€": 7, "ì½œë¡œì„¸ì›€ì˜ ì˜ì›…": 6},
            "ê´‘ì „ì‚¬": {"í”¼ì˜ ê°ˆì¦": 10, "ê´‘ê¸°ì˜ í˜": 9, "í¡í˜ˆ ê°•í™”": 8, "ë¶„ë…¸ ì œì–´": 7, "ì•¼ìƒ ë³¸ëŠ¥": 6},
            
            # ì›ê±°ë¦¬/ë¬¼ë¦¬ê³„ - ì •ë°€í•¨ê³¼ ê¸°ë™ì„± ì¤‘ì‹¬ 
            "ê¶ìˆ˜": {"ì •ë°€í•¨": 10, "ì§‘ì¤‘ë ¥": 9, "ì—°ì† ì‚¬ê²©": 8, "ì›ê±°ë¦¬ ì „ë¬¸ê°€": 7, "ì‚¬ëƒ¥ê¾¼ì˜ ì§ê°": 6},
            "ë„ì ": {"ë…ì™•ì˜ ê¶ŒëŠ¥": 10, "ë…ìˆ  ì§€ë°°": 9, "ë… ì´‰ì§„": 8, "ì¹¨ë¬µ ìˆ ": 7, "ë§¹ë… ë©´ì—­": 6},
            "ì•”ì‚´ì": {"ê·¸ë¦¼ì ì¡°ì‘": 10, "ê·¸ë¦¼ì ë°©ì–´": 9, "ê·¸ë¦¼ì ê°•í™”": 8, "ì¦‰ì‚¬ìˆ ": 7, "ì¹˜ëª…íƒ€ íŠ¹í™”": 6},
            "í•´ì ": {"ì´ë„ë¥˜ ë‹¬ì¸": 10, "ë³´ë¬¼ ê°ê°": 9, "í•­í•´ìˆ ": 8, "ì•½íƒˆ ì „ë¬¸ê°€": 7, "ìš´ëª…ì˜ ë°”ëŒ": 6},
            "ì‚¬ë¬´ë¼ì´": {"ë¬´ì‚¬ë„ ì •ì‹ ": 10, "ê±°í•© ë‹¬ì¸": 9, "ëª…ì˜ˆ ìˆ˜í˜¸": 8, "ê²€ì˜ ê¸¸": 7, "ì§‘ì¤‘ë ¥": 6},
            
            # ë§ˆë²•ê³„ - ì›ì†Œì™€ ë§ˆë‚˜ ê´€ë¦¬ ì¤‘ì‹¬
            "ì•„í¬ë©”ì´ì§€": {"ì›ì†Œ ë§ˆìŠ¤í„°": 10, "ë§ˆë ¥ ì¡°ì ˆ": 9, "ì›ì†Œ ìˆœí™˜": 8, "ë²ˆê°œ ì¹œí™”": 7, "ë§ˆë²• ì§€ì‹": 6},
            "ë„¤í¬ë¡œë§¨ì„œ": {"ì˜í˜¼ ì¡°ì‘": 10, "ì£½ìŒ ì¹œí™”": 9, "ì–¸ë°ë“œ ì§€ë°°": 8, "ìƒëª… í¡ìˆ˜": 7, "ê³µí¬ ìœ ë°œ": 6},
            "ì •ë ¹ìˆ ì‚¬": {"ì›ì†Œ ì¡°ì‘": 10, "ì •ë ¹ ì†Œí†µ": 9, "ì›ì†Œ ìœµí•©": 8, "ìì—° ì¹œí™”": 7, "ë§ˆë‚˜ íš¨ìœ¨": 6},
            "ì‹œê°„ìˆ ì‚¬": {"ì‹œê°„ ì¡°ì‘": 10, "ë¯¸ë˜ ì˜ˆì¸¡": 9, "ì‹œê³µê°„ ì¸ì‹": 8, "ì‹œê°„ ì—­í–‰": 7, "ì¸ê³¼ ì¡°ì‘": 6},
            "ì—°ê¸ˆìˆ ì‚¬": {"í™”í•™ ì§€ì‹": 10, "í­ë°œ ì œì–´": 9, "ë¬¼ì§ˆ ë³€í™˜": 8, "ì—°ì„±ìˆ ": 7, "ì‹¤í—˜ ì •ì‹ ": 6},
            "ì°¨ì›ìˆ ì‚¬": {"ê³µê°„ ì¡°ì‘": 10, "ì°¨ì› ì´ë™": 9, "ê³µê°„ ì¸ì‹": 8, "ì°¨ì› ê· ì—´": 7, "ë¬´í•œ ì§€ì‹": 6},
            
            # í•˜ì´ë¸Œë¦¬ë“œê³„ - ê· í˜• ì¡íŒ íŠ¹ì„±
            "ëª½í¬": {"ë‚´ê³µìˆ ": 10, "ì—°íƒ€ ì „ë¬¸ê°€": 9, "ì •ì‹  ìˆ˜ë ¨": 8, "ê¸° ì¡°ì ˆ": 7, "ì°¸ì„ ì˜ ê¹¨ë‹¬ìŒ": 6},
            "ë§ˆê²€ì‚¬": {"ë§ˆê²€ ì¡°í™”": 10, "ì›ì†Œ ê²€ìˆ ": 9, "ë§ˆë²• ê²€ê¸°": 8, "ì´ì¤‘ ìˆ˜ë ¨": 7, "ê· í˜• ê°ê°": 6},
            "ê¸°ê³„ê³µí•™ì": {"ê¸°ê³„ ì¡°ì‘": 10, "ì—ë„ˆì§€ ì œì–´": 9, "ë¡œë´‡ ê³µí•™": 8, "ê³¼í•™ ì§€ì‹": 7, "ì°½ì˜ì„±": 6},
            
            # ì„œí¬í„°ê³„ - íŒŒí‹° ì§€ì›ê³¼ ì¹˜ìœ  ì¤‘ì‹¬
            "ë°”ë“œ": {"íŒŒí‹° ì§€ì›": 10, "ìŒì•… ì¬ëŠ¥": 9, "ë§¤í˜¹ìˆ ": 8, "ì •ì‹  ì¡°ì‘": 7, "ì¹´ë¦¬ìŠ¤ë§ˆ": 6},
            "ì‹ ê´€": {"ì¹˜ìœ  ì „ë¬¸ê°€": 10, "ì‹ ì„± ê°€í˜¸": 9, "ì‹ ì•™ì‹¬": 8, "ì¶•ë³µìˆ ": 7, "ì •í™”": 6},
            "ë“œë£¨ì´ë“œ": {"ìì—° ì†Œí†µ": 10, "ë™ë¬¼ ë³€ì‹ ": 9, "ìì—° ë§ˆë²•": 8, "ìƒíƒœ ì§€ì‹": 7, "ì‹ë¬¼ ì„±ì¥": 6},
            "ë¬´ë‹¹": {"ì˜í˜¼ ì‹œì•¼": 10, "ì •ì‹  ì§€ë°°": 9, "ê·€ì‹  ì†Œí†µ": 8, "ì£¼ìˆ  ì§€ì‹": 7, "ì˜ì  ë³´í˜¸": 6},
            "ì² í•™ì": {"ë…¼ë¦¬ì  ì‚¬ê³ ": 10, "ì§„ë¦¬ ì¶”êµ¬": 9, "ì§€ì‹ ì¶•ì ": 8, "ì„¤ë“ìˆ ": 7, "í•™ìì˜ ì§ê°": 6}
        }
        
        return priorities.get(class_name, {})
    
    def _analyze_party(self, party: List[Character]):
        """íŒŒí‹° ë¶„ì„ ë° ì‹œë„ˆì§€ í‘œì‹œ"""
        print(f"\n{GREEN}=== ìƒì„±ëœ íŒŒí‹° ==={RESET}")
        
        # íŒŒí‹° êµ¬ì„± í‘œì‹œ
        for i, character in enumerate(party, 1):
            role = self._get_character_role(character.character_class)
            passives = [trait.name for trait in character.active_traits]
            
            print(f"{WHITE}{i}. {character.name}{RESET}")
            print(f"   ì§ì—…: {CYAN}{character.character_class}{RESET} ({role})")
            print(f"   ë ˆë²¨: {character.level}")
            print(f"   ìŠ¤íƒ¯: HP {character.max_hp}, ë¬¼ê³µ {character.physical_attack}, ë§ˆê³µ {character.magic_attack}")
            print(f"   íŒ¨ì‹œë¸Œ: {YELLOW}{', '.join(passives)}{RESET}")
            print()
        
        # ì—­í•  ë¶„ì„
        roles = self._analyze_roles([c.character_class for c in party])
        print(f"{BLUE}íŒŒí‹° ì—­í•  êµ¬ì„±:{RESET}")
        for role, count in roles.items():
            if count > 0:
                print(f"  {role}: {count}ëª…")
        
        # ì‹œë„ˆì§€ í™•ì¸
        synergies = self._check_synergies(party)
        if synergies:
            print(f"\n{MAGENTA}íŒŒí‹° ì‹œë„ˆì§€:{RESET}")
            for synergy in synergies:
                print(f"  âœ¨ {synergy}")
        
        print(f"\n{GREEN}íŒŒí‹° êµ¬ì„± ì™„ë£Œ! ğŸ‰{RESET}")
    
    def _get_character_role(self, class_name: str) -> str:
        """ìºë¦­í„°ì˜ ì—­í•  ë°˜í™˜"""
        for role, classes in self.ROLE_CLASSES.items():
            if class_name in classes:
                return role
        return "ê¸°íƒ€"
    
    def _check_synergies(self, party: List[Character]) -> List[str]:
        """íŒŒí‹° ì‹œë„ˆì§€ í™•ì¸"""
        synergies = []
        party_classes = [c.character_class for c in party]
        
        for combination, info in self.SYNERGY_COMBINATIONS.items():
            classes = combination.split(" + ")
            if all(cls in party_classes for cls in classes):
                synergies.append(f"{combination}: {info['effect']}")
        
        return synergies
    
    def get_balanced_party_from_list(self, unlocked_names: List[str]) -> List[str]:
        """í•´ê¸ˆëœ ìºë¦­í„° ëª©ë¡ì—ì„œ ê· í˜•ì¡íŒ íŒŒí‹° êµ¬ì„± (ì´ë¦„ë§Œ ë°˜í™˜)"""
        if len(unlocked_names) < 4:
            return unlocked_names
        
        # ì—­í• ë³„ë¡œ ë¶„ë¥˜
        available_by_role = {role: [] for role in self.ROLE_CLASSES.keys()}
        
        for name in unlocked_names:
            for role, classes in self.ROLE_CLASSES.items():
                if name in classes:
                    available_by_role[role].append(name)
                    break
        
        # ê· í˜•ì¡íŒ íŒŒí‹° êµ¬ì„± (ê° ì—­í• ì—ì„œ 1ëª…ì”©)
        selected = []
        
        # íƒ±ì»¤ 1ëª…
        if available_by_role["íƒ±ì»¤"]:
            selected.append(random.choice(available_by_role["íƒ±ì»¤"]))
        
        # ë”œëŸ¬ 1ëª…
        if available_by_role["ë”œëŸ¬"]:
            selected.append(random.choice(available_by_role["ë”œëŸ¬"]))
        
        # ë§ˆë²•ì‚¬ 1ëª…
        if available_by_role["ë§ˆë²•ì‚¬"]:
            selected.append(random.choice(available_by_role["ë§ˆë²•ì‚¬"]))
        
        # ì„œí¬í„° ë˜ëŠ” í•˜ì´ë¸Œë¦¬ë“œ 1ëª…
        support_pool = available_by_role["ì„œí¬í„°"] + available_by_role["í•˜ì´ë¸Œë¦¬ë“œ"]
        if support_pool:
            selected.append(random.choice(support_pool))
        
        # 4ëª…ì´ ì•ˆ ë˜ë©´ ë‚˜ë¨¸ì§€ í•´ê¸ˆëœ ìºë¦­í„°ë¡œ ì±„ìš°ê¸°
        remaining = [name for name in unlocked_names if name not in selected]
        while len(selected) < 4 and remaining:
            selected.append(remaining.pop(0))
        
        return selected[:4]
    
    def select_party_passive_effects(self):
        """íŒŒí‹° ì „ì²´ íŒ¨ì‹œë¸Œ íš¨ê³¼ ì„ íƒ - main.pyì™€ ë™ì¼í•œ ì‹œìŠ¤í…œ"""
        try:
            from game.cursor_menu_system import CursorMenu
            from game.color_text import bright_cyan, bright_yellow, yellow, green, red, bright_white, cyan, white
            
            # ğŸŒŸ ì™„ì „ ë¦¬ë©”ì´í¬ëœ ì°½ì˜ì  íŒ¨ì‹œë¸Œ ì‹œìŠ¤í…œ (1-10 ì½”ìŠ¤íŠ¸, ìµœëŒ€ 3ê°œ ì œí•œ)
            all_passive_effects = [
                # === 1ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ê¸°ì´ˆ íš¨ê³¼) ===
                {
                    "name": "ì²«ê±¸ìŒì˜ ìš©ê¸°", 
                    "description": "ì²« ë²ˆì§¸ ì „íˆ¬ì—ì„œ ëª¨ë“  ëŠ¥ë ¥ì¹˜ +50%",
                    "effect_type": "first_battle_boost",
                    "effect_value": {"all_stats": 0.50},
                    "cost": 1,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ë¯¸ë‹ˆë©€ë¦¬ìŠ¤íŠ¸", 
                    "description": "ì¸ë²¤í† ë¦¬ 50% ì´í•˜ì¼ ë•Œ SPD +15%, íšŒí”¼ìœ¨ +10%",
                    "effect_type": "minimalist",
                    "effect_value": {"speed_bonus": 0.15, "dodge_bonus": 0.10, "inventory_threshold": 0.50},
                    "cost": 1,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ìƒˆë²½ì˜ ì§‘ì¤‘", 
                    "description": "ì „íˆ¬ ì²« í„´ì— í–‰ë™ì†ë„ +100%",
                    "effect_type": "dawn_focus",
                    "effect_value": {"first_turn_speed": 1.00},
                    "cost": 1,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ì ˆì•½ ì •ì‹ ", 
                    "description": "ì•„ì´í…œ ì‚¬ìš© ì‹œ 25% í™•ë¥ ë¡œ ì†Œëª¨í•˜ì§€ ì•ŠìŒ",
                    "effect_type": "conservation",
                    "effect_value": {"save_chance": 0.25},
                    "cost": 1,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "í–‰ìš´ì˜ ë™ì „", 
                    "description": "ê³¨ë“œ ìŠµë“ ì‹œ 10% í™•ë¥ ë¡œ 2ë°°",
                    "effect_type": "lucky_coin",
                    "effect_value": {"double_chance": 0.10},
                    "cost": 1,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                
                # === 2ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ì‘ìš© íš¨ê³¼) ===
                {
                    "name": "ì—­ì „ì˜ ëª…ìˆ˜", 
                    "description": "HP 25% ì´í•˜ì¼ ë•Œ í¬ë¦¬í‹°ì»¬ í™•ë¥  +30%",
                    "effect_type": "comeback_master",
                    "effect_value": {"crit_bonus": 0.30, "hp_threshold": 0.25},
                    "cost": 2,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ëª¨í—˜ê°€ì˜ ì§ê°", 
                    "description": "ìˆ¨ê²¨ì§„ ë¬¸ ë°œê²¬ìœ¨ +40%, í•¨ì • ê°ì§€ +25%",
                    "effect_type": "adventurer_instinct",
                    "effect_value": {"secret_find": 0.40, "trap_detect": 0.25},
                    "cost": 2,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ì—°ì‡„ ë°˜ì‘", 
                    "description": "í¬ë¦¬í‹°ì»¬ íˆíŠ¸ ì‹œ ë‹¤ìŒ ê³µê²© ë°ë¯¸ì§€ +20% (3íšŒ ì¤‘ì²©)",
                    "effect_type": "chain_reaction",
                    "effect_value": {"damage_boost": 0.20, "max_stacks": 3},
                    "cost": 2,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ìˆ˜ì§‘ê°€ì˜ ëˆˆ", 
                    "description": "ë ˆì–´ ì•„ì´í…œ ë°œê²¬ìœ¨ +20%, ì¤‘ë³µ ì•„ì´í…œ ì‹œ ê³¨ë“œ ë³´ë„ˆìŠ¤ +50%",
                    "effect_type": "collector_eye",
                    "effect_value": {"rare_find": 0.20, "duplicate_bonus": 0.50},
                    "cost": 2,
                    "unlock_cost": 0,
                    "rarity": "common"
                },
                {
                    "name": "ì¼ì‚¬ì²œë¦¬", 
                    "description": "ê°™ì€ ìŠ¤í‚¬ ì—°ì† ì‚¬ìš© ì‹œ MP ì†Œëª¨ -10% (ìµœëŒ€ -50%)",
                    "effect_type": "momentum",
                    "effect_value": {"mp_reduction": 0.10, "max_reduction": 0.50},
                    "cost": 2,
                    "unlock_cost": 30,
                    "rarity": "uncommon"
                },
                {
                    "name": "ìœ„ê¸° ëŒ€ì‘", 
                    "description": "ìƒíƒœì´ìƒ ê±¸ë¦´ ë•Œ ì¦‰ì‹œ HP 15% íšŒë³µ",
                    "effect_type": "crisis_response",
                    "effect_value": {"heal_percent": 0.15},
                    "cost": 2,
                    "unlock_cost": 40,
                    "rarity": "uncommon"
                },
                
                # === 3ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ (ì „ëµì  íš¨ê³¼) ===
                {
                    "name": "ì™„ë²½ì£¼ì˜ì", 
                    "description": "í’€ HP/MPì¼ ë•Œ ëª¨ë“  í–‰ë™ íš¨ê³¼ +25%",
                    "effect_type": "perfectionist",
                    "effect_value": {"effect_boost": 0.25},
                    "cost": 3,
                    "unlock_cost": 50,
                    "rarity": "uncommon"
                },
                {
                    "name": "ë„ë°•ê¾¼ì˜ ì‹¬ë¦¬", 
                    "description": "ê³µê²©/ìŠ¤í‚¬ ì‚¬ìš© ì‹œ 10% í™•ë¥ ë¡œ 2ë°° íš¨ê³¼, 5% í™•ë¥ ë¡œ ì‹¤íŒ¨",
                    "effect_type": "gambler_mind",
                    "effect_value": {"double_chance": 0.10, "fail_chance": 0.05},
                    "cost": 3,
                    "unlock_cost": 60,
                    "rarity": "uncommon"
                },
                {
                    "name": "ì‹œë„ˆì§€ ë§ˆìŠ¤í„°", 
                    "description": "íŒŒí‹°ì›ê³¼ ê°™ì€ íƒ€ê²Ÿ ê³µê²© ì‹œ ë°ë¯¸ì§€ +35%",
                    "effect_type": "synergy_master",
                    "effect_value": {"synergy_damage": 0.35},
                    "cost": 3,
                    "unlock_cost": 70,
                    "rarity": "uncommon"
                }
            ]
            
            # ğŸ¯ íŒ¨ì‹œë¸Œ ê°œìˆ˜ ì œí•œ ì‹œìŠ¤í…œ (ìµœëŒ€ 3ê°œ)
            MAX_PASSIVE_COUNT = 3
            current_max_cost = 3  # ê¸°ë³¸ 3ì½”ìŠ¤íŠ¸, ìµœëŒ€ 10ê¹Œì§€ í™•ì¥ ê°€ëŠ¥
            
            print(f"\n{bright_cyan('ğŸŒŸ íŒŒí‹° íŒ¨ì‹œë¸Œ íš¨ê³¼ ì„ íƒ')}")
            print(f"{yellow('âš ï¸ íŒ¨ì‹œë¸ŒëŠ” ìµœëŒ€ 3ê°œê¹Œì§€, ì´ ì½”ìŠ¤íŠ¸ 3 ì´ë‚´ë¡œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.')}")
            print(f"{cyan('ğŸ’¡ 1-2ì½”ìŠ¤íŠ¸ íŒ¨ì‹œë¸Œ ì¡°í•©ìœ¼ë¡œ ì „ëµì ì¸ êµ¬ì„±ì„ í•´ë³´ì„¸ìš”!')}")
            
            selected_passives = []
            used_cost = 0
            
            while len(selected_passives) < MAX_PASSIVE_COUNT and used_cost < current_max_cost:
                # ì„ íƒ ê°€ëŠ¥í•œ íŒ¨ì‹œë¸Œë“¤ (ê¸°ë³¸ 3ì½”ìŠ¤íŠ¸ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ê²ƒë“¤ë§Œ)
                available_passives = [p for p in all_passive_effects 
                                    if p not in selected_passives 
                                    and p['cost'] <= (current_max_cost - used_cost)
                                    and p['unlock_cost'] == 0]  # ê¸°ë³¸ íŒ¨ì‹œë¸Œë§Œ
                
                if not available_passives:
                    break
                
                # ì»¤ì„œ ë©”ë‰´ë¡œ íŒ¨ì‹œë¸Œ ì„ íƒ (í˜ì´ì§€ë„¤ì´ì…˜ ì ìš©)
                try:
                    # í˜ì´ì§€ë‹¹ í‘œì‹œí•  íŒ¨ì‹œë¸Œ ê°œìˆ˜
                    PASSIVES_PER_PAGE = 8
                    total_pages = (len(available_passives) + PASSIVES_PER_PAGE - 1) // PASSIVES_PER_PAGE
                    current_page = 0
                    
                    while True:
                        # í˜„ì¬ í˜ì´ì§€ì˜ íŒ¨ì‹œë¸Œë“¤
                        start_idx = current_page * PASSIVES_PER_PAGE
                        end_idx = min(start_idx + PASSIVES_PER_PAGE, len(available_passives))
                        page_passives = available_passives[start_idx:end_idx]
                        
                        options = []
                        descriptions = []
                        
                        # í˜„ì¬ í˜ì´ì§€ì˜ íŒ¨ì‹œë¸Œë“¤ ì¶”ê°€
                        for passive in page_passives:
                            cost = passive['cost']
                            rarity_color = {"common": "ğŸ”·", "uncommon": "ğŸ”¶", "rare": "ğŸ”¥", "epic": "ğŸ’œ", "legendary": "âœ¨", "mythic": "ğŸ’«"}
                            rarity_icon = rarity_color.get(passive.get('rarity', 'common'), "ğŸ”·")
                            
                            option_text = f"{rarity_icon} {passive['name']} [{cost}ì½”ìŠ¤íŠ¸]"
                            description = f"{passive['description']}"
                            
                            options.append(option_text)
                            descriptions.append(description)
                        
                        # ë„¤ë¹„ê²Œì´ì…˜ ì˜µì…˜ë“¤ ì¶”ê°€
                        if total_pages > 1:
                            if current_page > 0:
                                options.append("â¬…ï¸ ì´ì „ í˜ì´ì§€")
                                descriptions.append("ì´ì „ í˜ì´ì§€ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤")
                            if current_page < total_pages - 1:
                                options.append("â¡ï¸ ë‹¤ìŒ í˜ì´ì§€")
                                descriptions.append("ë‹¤ìŒ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤")
                        
                        # ì„ íƒ ì™„ë£Œ ì˜µì…˜ ì¶”ê°€
                        options.append("âœ… ì„ íƒ ì™„ë£Œ (íŒ¨ì‹œë¸Œ ì—†ì´ ì§„í–‰)")
                        descriptions.append("ë” ì´ìƒ íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ì§€ ì•Šê³  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤")
                        
                        # ìƒíƒœ ì •ë³´ (í˜ì´ì§€ ì •ë³´ í¬í•¨)
                        status_info = f"ì½”ìŠ¤íŠ¸: {used_cost}/{current_max_cost} | ê°œìˆ˜: {len(selected_passives)}/{MAX_PASSIVE_COUNT}"
                        if total_pages > 1:
                            status_info += f" | í˜ì´ì§€: {current_page + 1}/{total_pages}"
                        
                        # í˜„ì¬ ì„ íƒëœ íŒ¨ì‹œë¸Œë“¤ ì •ë³´
                        selected_info = ""
                        if selected_passives:
                            selected_info = "\nì„ íƒëœ íŒ¨ì‹œë¸Œ:\n"
                            for p in selected_passives:
                                selected_info += f"â€¢ {p['name']} [{p['cost']}ì½”ìŠ¤íŠ¸]\n"
                        
                        # ì»¤ì„œ ë©”ë‰´ ìƒì„±
                        menu = CursorMenu(
                            title=f"ğŸŒŸ íŒŒí‹° íŒ¨ì‹œë¸Œ íš¨ê³¼ ì„ íƒ\n{status_info}{selected_info}",
                            options=options,
                            descriptions=descriptions,
                            cancellable=True
                        )
                        
                        result = menu.run()
                        
                        if result is None:  # ì·¨ì†Œ
                            return []
                        elif result < len(page_passives):  # íŒ¨ì‹œë¸Œ ì„ íƒ
                            selected_passive = page_passives[result]
                            selected_passives.append(selected_passive)
                            used_cost += selected_passive['cost']
                            
                            print(f"\n{GREEN}âœ… {selected_passive['name']} íŒ¨ì‹œë¸Œê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
                            print(f"{CYAN}ğŸ’¡ {selected_passive['description']}{RESET}")
                            
                            if used_cost >= current_max_cost or len(selected_passives) >= MAX_PASSIVE_COUNT:
                                print(f"\n{YELLOW}ğŸ¯ ì œí•œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!{RESET}")
                                break
                            break  # íŒ¨ì‹œë¸Œ ì„ íƒ í›„ ë©”ì¸ ë£¨í”„ë¡œ
                        else:
                            # ë„¤ë¹„ê²Œì´ì…˜ ë˜ëŠ” ì™„ë£Œ ì²˜ë¦¬
                            nav_start = len(page_passives)
                            relative_choice = result - nav_start
                            
                            nav_options = []
                            if total_pages > 1:
                                if current_page > 0:
                                    nav_options.append("prev")
                                if current_page < total_pages - 1:
                                    nav_options.append("next")
                            nav_options.append("complete")
                            
                            if relative_choice < len(nav_options):
                                choice = nav_options[relative_choice]
                                if choice == "prev":
                                    current_page = max(0, current_page - 1)
                                elif choice == "next":
                                    current_page = min(total_pages - 1, current_page + 1)
                                elif choice == "complete":
                                    return selected_passives
                            
                    if used_cost >= current_max_cost or len(selected_passives) >= MAX_PASSIVE_COUNT:
                        break
                
                except ImportError:
                    # ì»¤ì„œ ë©”ë‰´ ì—†ì„ ë•Œ ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
                    print(f"\n{bright_white('ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨ì‹œë¸Œ ëª©ë¡:')} (ì½”ìŠ¤íŠ¸: {used_cost}/{current_max_cost}, ê°œìˆ˜: {len(selected_passives)}/{MAX_PASSIVE_COUNT})")
                    
                    options = []
                    for i, passive in enumerate(available_passives, 1):
                        cost = passive['cost']
                        print(f"{bright_yellow(f'{i}.')} {white(passive['name'])} [{cost}ì½”ìŠ¤íŠ¸] - {cyan(passive['description'])}")
                        options.append(str(i))
                    
                    print(f"{bright_yellow(f'{len(available_passives) + 1}.')} {white('ì„ íƒ ì™„ë£Œ (íŒ¨ì‹œë¸Œ ì—†ì´ ì§„í–‰)')}")
                    options.append(str(len(available_passives) + 1))
                    
                    choice = self.keyboard.get_key_input(f"\n{bright_white('ì„ íƒí•˜ì„¸ìš”')}: ", options)
                    choice_idx = int(choice) - 1
                    
                    if choice_idx < len(available_passives):
                        # íŒ¨ì‹œë¸Œ ì„ íƒ
                        selected_passive = available_passives[choice_idx]
                        selected_passives.append(selected_passive)
                        used_cost += selected_passive['cost']
                        
                        print(f"\n{green('âœ…')} {bright_white(selected_passive['name'])} íŒ¨ì‹œë¸Œê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!")
                        print(f"{cyan('ğŸ’¡')} {selected_passive['description']}")
                        
                        if used_cost >= current_max_cost or len(selected_passives) >= MAX_PASSIVE_COUNT:
                            print(f"\n{bright_yellow('ğŸ¯ ì œí•œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!')}")
                            break
                    else:
                        # ì„ íƒ ì™„ë£Œ
                        break
                else:
                    # ì„ íƒ ì™„ë£Œ
                    break
            
            # ì„ íƒ ê²°ê³¼ ì¶œë ¥
            if selected_passives:
                print(f"\n{bright_cyan('='*50)}")
                print(f"{green('ğŸ‰ ì„ íƒëœ íŒŒí‹° íŒ¨ì‹œë¸Œ íš¨ê³¼:')}")
                for i, passive in enumerate(selected_passives, 1):
                    print(f"  {bright_yellow(f'{i}.')} {white(passive['name'])} - {cyan(passive['description'])}")
                print(f"{bright_cyan('='*50)}")
                
                # íŒ¨ì‹œë¸Œ íš¨ê³¼ë¥¼ íŒŒí‹°ì— ì €ì¥ (ì‹¤ì œ ì ìš©ì€ ê²Œì„ ë‚´ì—ì„œ)
                return selected_passives
            else:
                print(f"\n{yellow('íŒ¨ì‹œë¸Œ íš¨ê³¼ ì—†ì´ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.')}")
                return []
            
        except Exception as e:
            print(f"âš ï¸ íŒ¨ì‹œë¸Œ ì„ íƒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
            return []
    
    def _get_available_traits(self, job: str) -> List[str]:
        """ì§ì—…ë³„ ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„± ëª©ë¡ ë°˜í™˜ - 6ë‹¨ê³„ ì™„ì „ì²´ ì‹œìŠ¤í…œ"""
        # ëª¨ë“  íŠ¹ì„± ì´ë¦„ ë¦¬ìŠ¤íŠ¸ (ê²Œì„ ì‹œìŠ¤í…œê³¼ ë™ê¸°í™” í•„ìš”)
        all_traits = [
            # ì „íˆ¬ íŠ¹ì„± - 6ë‹¨ê³„ ì™„ì „ì²´ í¬í•¨
            "6ë‹¨ê³„ ì™„ì „ì²´", "ì „ì¥ì˜ ì§€ë°°ì", "íŒ¨ë§ ë§ˆìŠ¤í„°", "í”¼ì˜ ê°ˆì¦",
            "ì‹ ì„±í•œ ë³´í˜¸", "ìˆ˜í˜¸ ë³¸ëŠ¥", "ë¶ˆêµ´ì˜ ì˜ì§€", "ê¸°ì‚¬ë„ ì •ì‹ ",
            "ê·¸ë¦¼ì ì¡°ì‘", "ì•”ì‚´ìì˜ ì§ê°", "ë…ì„± íŠ¹í™”", "ìŠ¤í…”ìŠ¤ ë§ˆìŠ¤í„°",
            
            # ë§ˆë²• íŠ¹ì„±
            "ì›ì†Œ ë§ˆìŠ¤í„°", "ë§ˆë ¥ ì¡°ì ˆ", "ì •ë ¹ ì†Œí†µ", "ì‹œê°„ ì¡°ì‘",
            "ìƒëª…ë ¥ ì¡°ì‘", "ì–¸ë°ë“œ ì§€ë°°", "ì˜í˜¼ í¡ìˆ˜", "ì–´ë‘ ì˜ í˜",
            "ì°¨ì› ì—¬í–‰", "ê³µê°„ ì¡°ì‘", "í˜„ì‹¤ ì™œê³¡", "ì°¨ì›ì˜ ë¬¸",
            
            # ì§€ì› íŠ¹ì„±  
            "íŒŒí‹° ì§€ì›", "ì¹˜ìœ  ì „ë¬¸ê°€", "ì‹ ì„± ê°€í˜¸", "ìŒì•… ì¬ëŠ¥",
            "ìì—° ì†Œí†µ", "ì•¼ìƒ í˜•íƒœ", "ë™ë¬¼ ì¹œí™”", "ì¹˜ìœ ìˆ ",
            "ê¸°ê³„ ì¡°ì‘", "ì—°ê¸ˆìˆ  ì§€ì‹", "ë°œëª…í’ˆ ì œì‘", "ê³¼í•™ì  ì‚¬ê³ ",
            
            # íŠ¹ìˆ˜ íŠ¹ì„±
            "ì˜í˜¼ ì¡°ì‘", "ì •ì‹ ë ¥", "ì˜ì  ë³´í˜¸", "ë¬´ë‹¹ì˜ ì§€í˜œ",
            "ê²€ê¸° ì¡°ì‘", "íˆ¬ê¸°ì¥ì˜ ê²½í—˜", "ì½¤ë³´ ë§ˆìŠ¤í„°", "ê²©íˆ¬ ê¸°ìˆ ",
            "ìš©ì˜ í˜ˆí†µ", "í™”ì—¼ ì €í•­", "ë“œë˜ê³¤ í•˜íŠ¸", "ìš©ì˜ ë¹„ëŠ˜",
            "ë¬´ì‚¬ë„ ì •ì‹ ", "ì •ë°€í•¨", "ì§‘ì¤‘ë ¥", "ì™„ë²½í•œ ìì„¸",
            "ë…¼ë¦¬ì  ì‚¬ê³ ", "ë¶„ì„ ëŠ¥ë ¥", "ì² í•™ì  ì‚¬ê³ ", "ì§„ë¦¬ íƒêµ¬",
            "ê´‘ì „ì‚¬ì˜ ë¶„ë…¸", "í”¼ì˜ ì¶•ì œ", "ê´‘ê¸°ì˜ í˜", "íŒŒê´´ì˜ ì¶©ë™"
        ]
        
        # ì§ì—…ë³„ íŠ¹í™” íŠ¹ì„± (ìš°ì„  ìˆœìœ„ê°€ ë†’ì€ íŠ¹ì„±ë“¤) - 6ë‹¨ê³„ ì™„ì „ì²´ í¬í•¨
        job_specific_traits = {
            "ì „ì‚¬": ["6ë‹¨ê³„ ì™„ì „ì²´", "ì „ì¥ì˜ ì§€ë°°ì", "íŒ¨ë§ ë§ˆìŠ¤í„°", "í”¼ì˜ ê°ˆì¦"],
            "ì•„í¬ë©”ì´ì§€": ["ì›ì†Œ ë§ˆìŠ¤í„°", "ë§ˆë ¥ ì¡°ì ˆ", "ì •ë ¹ ì†Œí†µ", "ì‹œê°„ ì¡°ì‘"],
            "ê¶ìˆ˜": ["ì •ë°€í•¨", "ì§‘ì¤‘ë ¥", "ì™„ë²½í•œ ìì„¸", "6ë‹¨ê³„ ì™„ì „ì²´"],
            "ë„ì ": ["ê·¸ë¦¼ì ì¡°ì‘", "ì•”ì‚´ìì˜ ì§ê°", "ë…ì„± íŠ¹í™”", "ìŠ¤í…”ìŠ¤ ë§ˆìŠ¤í„°"],
            "ì„±ê¸°ì‚¬": ["ì‹ ì„±í•œ ë³´í˜¸", "ìˆ˜í˜¸ ë³¸ëŠ¥", "ë¶ˆêµ´ì˜ ì˜ì§€", "ê¸°ì‚¬ë„ ì •ì‹ "],
            "ì•”í‘ê¸°ì‚¬": ["ìƒëª…ë ¥ ì¡°ì‘", "ì–´ë‘ ì˜ í˜", "í”¼ì˜ ê°ˆì¦", "ì˜í˜¼ í¡ìˆ˜"],
            "ëª½í¬": ["ì½¤ë³´ ë§ˆìŠ¤í„°", "ê²©íˆ¬ ê¸°ìˆ ", "ì •ì‹ ë ¥", "ì™„ë²½í•œ ìì„¸"],
            "ë°”ë“œ": ["ìŒì•… ì¬ëŠ¥", "íŒŒí‹° ì§€ì›", "ì •ì‹ ë ¥", "ì˜ì  ë³´í˜¸"],
            "ë„¤í¬ë¡œë§¨ì„œ": ["ìƒëª…ë ¥ ì¡°ì‘", "ì–¸ë°ë“œ ì§€ë°°", "ì˜í˜¼ í¡ìˆ˜", "ì–´ë‘ ì˜ í˜"],
            "ìš©ê¸°ì‚¬": ["ìš©ì˜ í˜ˆí†µ", "í™”ì—¼ ì €í•­", "ë“œë˜ê³¤ í•˜íŠ¸", "ìš©ì˜ ë¹„ëŠ˜"],
            "ê²€ì„±": ["ê²€ê¸° ì¡°ì‘", "ë¬´ì‚¬ë„ ì •ì‹ ", "ì •ë°€í•¨", "ì§‘ì¤‘ë ¥"],
            "ì •ë ¹ìˆ ì‚¬": ["ì •ë ¹ ì†Œí†µ", "ì›ì†Œ ë§ˆìŠ¤í„°", "ìì—° ì†Œí†µ", "ë§ˆë ¥ ì¡°ì ˆ"],
            "ì‹œê°„ìˆ ì‚¬": ["ì‹œê°„ ì¡°ì‘", "í˜„ì‹¤ ì™œê³¡", "ì°¨ì› ì—¬í–‰", "ê³µê°„ ì¡°ì‘"],
            "ì—°ê¸ˆìˆ ì‚¬": ["í­ë°œ ì—°êµ¬", "í”Œë¼ìŠ¤í¬ ë‹¬ì¸", "ì›ì†Œ ë³€í™˜", "ìƒëª… ì—°ì„±"],
            "ì°¨ì›ìˆ ì‚¬": ["ì°¨ì› ì—¬í–‰", "ê³µê°„ ì¡°ì‘", "í˜„ì‹¤ ì™œê³¡", "ì°¨ì›ì˜ ë¬¸"],
            "ì•”ì‚´ì": ["ê·¸ë¦¼ì ì¡°ì‘", "ê·¸ë¦¼ì ê°•í™”", "ê·¸ë¦¼ì ë¶„ì‹ ", "ê·¸ë¦¼ì ìˆ™ë ¨"],
            "ê¸°ê³„ê³µí•™ì": ["ê¸°ê³„ ì •ë°€", "ë°œëª…í’ˆ ì œì‘", "ê¸°ê³„ ìˆ™ë ¨", "ê°•í™” ì¥ë¹„"],
            "ë¬´ë‹¹": ["ì˜í˜¼ ì¡°ì‘", "ì •ì‹ ë ¥", "ì˜ì  ë³´í˜¸", "ë¬´ë‹¹ì˜ ì§€í˜œ"],
            "í•´ì ": ["6ë‹¨ê³„ ì™„ì „ì²´", "íˆ¬ê¸°ì¥ì˜ ê²½í—˜", "íŒŒí‹° ì§€ì›", "ê²©íˆ¬ ê¸°ìˆ "],
            "ì‚¬ë¬´ë¼ì´": ["ë¬´ì‚¬ë„ ì •ì‹ ", "ì •ë°€í•¨", "ì§‘ì¤‘ë ¥", "ì™„ë²½í•œ ìì„¸"],
            "ë“œë£¨ì´ë“œ": ["ìì—° ì†Œí†µ", "ì•¼ìƒ ë³¸ëŠ¥", "ì‹ë¬¼ ì¹œí™”", "ê³„ì ˆì˜ í˜"],
            "ì² í•™ì": ["ë…¼ë¦¬ì  ì‚¬ê³ ", "ì² í•™ì  í†µì°°", "ì² í•™ì  ì‚¬ê³ ", "ì§„ë¦¬ íƒêµ¬"],
            "ê²€íˆ¬ì‚¬": ["íˆ¬ê¸°ì¥ì˜ ê²½í—˜", "ê²©íˆ¬ ê¸°ìˆ ", "ì½¤ë³´ ë§ˆìŠ¤í„°", "ì „ì¥ì˜ ì§€ë°°ì"],
            "ê¸°ì‚¬": ["ê¸°ì‚¬ë„ ì •ì‹ ", "ìˆ˜í˜¸ ë³¸ëŠ¥", "ì‹ ì„±í•œ ë³´í˜¸", "ë¶ˆêµ´ì˜ ì˜ì§€"],
            "ì‹ ê´€": ["ì‹ ì„± ê°€í˜¸", "ì¶•ë³µì˜ ì˜¤ë¼", "íŒŒí‹° ì§€ì›", "ì˜ì  ë³´í˜¸"],
            "ë§ˆê²€ì‚¬": ["ê²€ê¸° ì¡°ì‘", "ì›ì†Œ ë§ˆìŠ¤í„°", "ë§ˆë ¥ ì¡°ì ˆ", "ë¬´ì‚¬ë„ ì •ì‹ "],
            "ê´‘ì „ì‚¬": ["ê´‘ì „ì‚¬ì˜ ë¶„ë…¸", "í”¼ì˜ ì¶•ì œ", "ê´‘ê¸°ì˜ í˜", "íŒŒê´´ì˜ ì¶©ë™"]
        }
        
        # í•´ë‹¹ ì§ì—…ì˜ íŠ¹í™” íŠ¹ì„±ì´ ìˆìœ¼ë©´ ë°˜í™˜, ì—†ìœ¼ë©´ ëª¨ë“  íŠ¹ì„± ë°˜í™˜
        if job in job_specific_traits:
            return job_specific_traits[job]
        else:
            return all_traits[:8]  # ê¸°ë³¸ì ìœ¼ë¡œ 8ê°œë§Œ ë°˜í™˜
    
    def _display_party_summary(self, party: List[Character]):
        """íŒŒí‹° ì •ë³´ë¥¼ ê°„ê²°í•˜ê²Œ í‘œì‹œ"""
        if not party:
            return
        
        print(f"\n{CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{RESET}")
        print(f"{BRIGHT_YELLOW}ğŸ‰ ì§ˆë¬¸ ê¸°ë°˜ ë§ì¶¤ íŒŒí‹° ì™„ì„±!{RESET}")
        print(f"{CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{RESET}")
        
        for i, char in enumerate(party, 1):
            # ì§ì—…ë³„ ìƒ‰ìƒê³¼ ì—­í•  ì•„ì´ì½˜
            job_color = self._get_job_color(char.character_class)
            role_icon = self._get_role_icon(char.character_class)
            
            # íŠ¹ì„± ì •ë³´ (ìµœëŒ€ 2ê°œê¹Œì§€ë§Œ í‘œì‹œ)
            trait_info = ""
            if hasattr(char, 'traits') and char.traits:
                trait_names = char.traits[:2]  # ìµœëŒ€ 2ê°œê¹Œì§€
                if trait_names:
                    trait_info = f" | íŠ¹ì„±: {', '.join(trait_names)}"
            elif hasattr(char, 'selected_traits') and char.selected_traits:
                trait_names = [trait.name if hasattr(trait, 'name') else str(trait) 
                             for trait in char.selected_traits[:2]]
                if trait_names:
                    trait_info = f" | íŠ¹ì„±: {', '.join(trait_names)}"
            
            print(f"{WHITE}{i}.{RESET} {role_icon} {job_color}{char.name}{RESET} "
                  f"({job_color}{char.character_class}{RESET}) "
                  f"Lv.{char.level}{trait_info}")
        
        # íŒŒí‹° ë°¸ëŸ°ìŠ¤ ë¶„ì„
        balance = self._analyze_party_balance(party)
        print(f"\n{MAGENTA}ğŸ“Š íŒŒí‹° ë°¸ëŸ°ìŠ¤: {balance}{RESET}")
        print(f"{CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{RESET}")
    
    def _get_role_icon(self, job: str) -> str:
        """ì§ì—…ë³„ ì—­í•  ì•„ì´ì½˜ ë°˜í™˜ - í†µì¼ëœ ë¶„ë¥˜"""
        tank_jobs = ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬"]
        dps_jobs = ["ê¶ìˆ˜", "ë„ì ", "ì•”ì‚´ì", "ê²€ì„±", "ì‚¬ë¬´ë¼ì´"]
        mage_jobs = ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë§ˆê²€ì‚¬"]
        support_jobs = ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹", "ì² í•™ì"]
        hybrid_jobs = ["ì•”í‘ê¸°ì‚¬", "ëª½í¬", "ìš©ê¸°ì‚¬", "ê¸°ê³„ê³µí•™ì", "í•´ì "]
        
        if job in tank_jobs:
            return "ğŸ›¡ï¸"
        elif job in dps_jobs:
            return "âš”ï¸"
        elif job in mage_jobs:
            return "ğŸ”®"
        elif job in support_jobs:
            return "ğŸ’«"
        elif job in hybrid_jobs:
            return "ğŸŒŸ"
        else:
            return "â“"
    
    def _get_job_color(self, job: str) -> str:
        """ì§ì—…ë³„ ìƒ‰ìƒ ë°˜í™˜"""
        tank_jobs = ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬"]
        dps_jobs = ["ê¶ìˆ˜", "ë„ì ", "ì•”ì‚´ì", "ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬", "ì‚¬ë¬´ë¼ì´"]
        mage_jobs = ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë§ˆê²€ì‚¬"]
        support_jobs = ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹", "ì² í•™ì"]
        hybrid_jobs = ["ì•”í‘ê¸°ì‚¬", "ëª½í¬", "ìš©ê¸°ì‚¬", "ê¸°ê³„ê³µí•™ì", "í•´ì "]
        
        if job in tank_jobs:
            return CYAN  # íŒŒë€ìƒ‰ - íƒ±ì»¤
        elif job in dps_jobs:
            return RED   # ë¹¨ê°„ìƒ‰ - ë”œëŸ¬
        elif job in mage_jobs:
            return MAGENTA  # ìì£¼ìƒ‰ - ë§ˆë²•ì‚¬
        elif job in support_jobs:
            return GREEN    # ì´ˆë¡ìƒ‰ - ì„œí¬í„°
        elif job in hybrid_jobs:
            return YELLOW   # ë…¸ë€ìƒ‰ - í•˜ì´ë¸Œë¦¬ë“œ
        else:
            return WHITE
    
    def _analyze_party_balance(self, party: List[Character]) -> str:
        """íŒŒí‹° ë°¸ëŸ°ìŠ¤ ë¶„ì„"""
        if not party:
            return "íŒŒí‹° ì—†ìŒ"
        
        tank_count = 0
        dps_count = 0
        mage_count = 0
        support_count = 0
        hybrid_count = 0
        
        tank_jobs = ["ì „ì‚¬", "ì„±ê¸°ì‚¬", "ê¸°ì‚¬"]
        dps_jobs = ["ê¶ìˆ˜", "ë„ì ", "ì•”ì‚´ì", "ê²€ì„±", "ê²€íˆ¬ì‚¬", "ê´‘ì „ì‚¬", "ì‚¬ë¬´ë¼ì´"]
        mage_jobs = ["ì•„í¬ë©”ì´ì§€", "ë„¤í¬ë¡œë§¨ì„œ", "ì •ë ¹ìˆ ì‚¬", "ì‹œê°„ìˆ ì‚¬", "ì—°ê¸ˆìˆ ì‚¬", "ì°¨ì›ìˆ ì‚¬", "ë§ˆê²€ì‚¬"]
        support_jobs = ["ë°”ë“œ", "ì‹ ê´€", "ë“œë£¨ì´ë“œ", "ë¬´ë‹¹", "ì² í•™ì"]
        hybrid_jobs = ["ì•”í‘ê¸°ì‚¬", "ëª½í¬", "ìš©ê¸°ì‚¬", "ê¸°ê³„ê³µí•™ì", "í•´ì "]
        
        for char in party:
            job = char.character_class
            if job in tank_jobs:
                tank_count += 1
            elif job in dps_jobs:
                dps_count += 1
            elif job in mage_jobs:
                mage_count += 1
            elif job in support_jobs:
                support_count += 1
            elif job in hybrid_jobs:
                hybrid_count += 1
        
        # ë°¸ëŸ°ìŠ¤ í‰ê°€
        balance_parts = []
        if tank_count > 0:
            balance_parts.append(f"ğŸ›¡ï¸Ã—{tank_count}")
        if dps_count > 0:
            balance_parts.append(f"âš”ï¸Ã—{dps_count}")
        if mage_count > 0:
            balance_parts.append(f"ğŸ”®Ã—{mage_count}")
        if support_count > 0:
            balance_parts.append(f"ğŸ’«Ã—{support_count}")
        if hybrid_count > 0:
            balance_parts.append(f"ğŸŒŸÃ—{hybrid_count}")
        
        balance_str = " ".join(balance_parts)
        
        # ë°¸ëŸ°ìŠ¤ ë“±ê¸‰ íŒì •
        total_roles = len([x for x in [tank_count, dps_count, mage_count, support_count] if x > 0])
        if total_roles >= 3:
            balance_str += " (ê· í˜•ì¡íŒ íŒŒí‹° âœ¨)"
        elif total_roles == 2:
            balance_str += " (ì–‘í˜¸í•œ ë°¸ëŸ°ìŠ¤ âš–ï¸)"
        else:
            balance_str += " (íŠ¹í™” íŒŒí‹° ğŸ¯)"
        
        return balance_str
    
    def _select_best_trait_combination_dev_mode(self, character: Character, available_indices: List[int], 
                                              user_tags: List[str], trait_scores: Dict[str, int], 
                                              priority_scores: Dict[int, int] = None):
        """ê°œë°œ ëª¨ë“œì—ì„œ 2ê°œ íŠ¹ì„± ì„ íƒ"""
        if not available_indices:
            character.select_passive_traits([])
            return
        
        # ì ìˆ˜ìˆœìœ¼ë¡œ ì •ë ¬
        scored_indices = []
        for i in available_indices:
            score = priority_scores.get(i, 0) if priority_scores else 0
            scored_indices.append((i, score))
        
        # ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
        scored_indices.sort(key=lambda x: x[1], reverse=True)
        
        # ìƒìœ„ 2ê°œ ì„ íƒ (ê°€ëŠ¥í•œ ê²½ìš°)
        selected_indices = []
        for i, score in scored_indices[:2]:
            selected_indices.append(i)
        
        # íŠ¹ì„± ì ìš©
        if selected_indices:
            character.select_passive_traits(selected_indices)
            selected_names = [character.available_traits[i].name for i in selected_indices]
            print(f"{GREEN}  âœ… {character.name} - ìë™ ì„ íƒëœ íŠ¹ì„± ({len(selected_names)}ê°œ): {', '.join(selected_names)}{RESET}")
        else:
            character.select_passive_traits([])
            print(f"{YELLOW}  âš ï¸ {character.name} - ì„ íƒëœ íŠ¹ì„± ì—†ìŒ{RESET}")
    
    def _update_difficulty_scaling(self, party: List[Character]):
        """íŒŒí‹°ì— ë§ì¶° ì  ë‚œì´ë„ ìŠ¤ì¼€ì¼ë§ ì—…ë°ì´íŠ¸"""
        try:
            from game.dynamic_enemy_scaling import update_difficulty_for_party, show_current_difficulty
            
            # íŒŒí‹° ë¶„ì„ ì—…ë°ì´íŠ¸
            update_difficulty_for_party(party)
            
            # í˜„ì¬ ë‚œì´ë„ ì •ë³´ í‘œì‹œ
            show_current_difficulty()
            
        except ImportError:
            print(f"{YELLOW}âš ï¸ ë™ì  ë‚œì´ë„ ì‹œìŠ¤í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.{RESET}")
        except Exception as e:
            print(f"{RED}âš ï¸ ë‚œì´ë„ ë¶„ì„ ì¤‘ ì˜¤ë¥˜: {e}{RESET}")

    def build_party_from_saved_characters(self) -> Optional[List[Character]]:
        """ì €ì¥ëœ ìºë¦­í„°ë“¤ì—ì„œ ìµœëŒ€ 4ëª…ì„ ì„ íƒí•˜ì—¬ íŒŒí‹° êµ¬ì„±"""
        import json
        import os
        from glob import glob
        
        try:
            # ì €ì¥ íŒŒì¼ë“¤ ì°¾ê¸°
            save_files = glob("saves/*.json") + glob("*.json")
            save_files = [f for f in save_files if f.startswith(("save_", "saves/save_"))]
            
            if not save_files:
                print(f"{RED}ì €ì¥ëœ ê²Œì„ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return None
            
            # ëª¨ë“  ì €ì¥ íŒŒì¼ì—ì„œ ìºë¦­í„° ì •ë³´ ìˆ˜ì§‘
            all_characters = []
            for save_file in save_files:
                try:
                    with open(save_file, 'r', encoding='utf-8') as f:
                        save_data = json.load(f)
                    
                    # íŒŒí‹° ë©¤ë²„ë“¤ ì¶”ì¶œ
                    if 'party' in save_data:
                        for char_data in save_data['party']:
                            character_info = {
                                'name': char_data.get('name', 'Unknown'),
                                'class': char_data.get('character_class', 'Unknown'),
                                'level': char_data.get('level', 1),
                                'hp': char_data.get('max_hp', 100),
                                'mp': char_data.get('max_mp', 20),
                                'save_file': save_file,
                                'original_data': char_data
                            }
                            all_characters.append(character_info)
                except Exception as e:
                    print(f"{YELLOW}ì €ì¥ íŒŒì¼ {save_file} ë¡œë“œ ì‹¤íŒ¨: {e}{RESET}")
                    continue
            
            if not all_characters:
                print(f"{RED}ì €ì¥ëœ ìºë¦­í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return None
            
            # ì¤‘ë³µ ì œê±° (ì´ë¦„ + í´ë˜ìŠ¤ë¡œ êµ¬ë¶„)
            unique_characters = []
            seen = set()
            for char in all_characters:
                key = (char['name'], char['class'])
                if key not in seen:
                    unique_characters.append(char)
                    seen.add(key)
            
            print(f"\n{CYAN}=== ì €ì¥ëœ ìºë¦­í„° ì„ íƒ ==={RESET}")
            print(f"{YELLOW}ë°œê²¬ëœ ìºë¦­í„°: {len(unique_characters)}ëª…{RESET}")
            print(f"{YELLOW}ìµœëŒ€ 4ëª…ê¹Œì§€ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.{RESET}\n")
            
            # ìºë¦­í„° ëª©ë¡ í‘œì‹œ
            for i, char in enumerate(unique_characters):
                print(f"{WHITE}{i+1:2}. {BOLD}{char['name']}{RESET} ({char['class']}) - Lv.{char['level']}")
                print(f"     HP: {char['hp']} | MP: {char['mp']} | ì¶œì²˜: {char['save_file']}")
                print()
            
            # ì‚¬ìš©ì ì„ íƒ ë°›ê¸°
            selected_indices = []
            while len(selected_indices) < 4:
                try:
                    if len(selected_indices) == 0:
                        prompt = f"{GREEN}ì„ íƒí•  ìºë¦­í„° ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (1-{len(unique_characters)}, 'done'ìœ¼ë¡œ ì™„ë£Œ): {RESET}"
                    else:
                        selected_names = [unique_characters[i]['name'] for i in selected_indices]
                        prompt = f"{GREEN}ì¶”ê°€ ìºë¦­í„° ì„ íƒ ({len(selected_indices)}/4) - í˜„ì¬: {', '.join(selected_names)} (ë²ˆí˜¸ ì…ë ¥ ë˜ëŠ” 'done'): {RESET}"
                    
                    user_input = input(prompt).strip()
                    
                    if user_input.lower() in ['done', 'ì™„ë£Œ', 'd']:
                        if len(selected_indices) > 0:
                            break
                        else:
                            print(f"{RED}ìµœì†Œ 1ëª…ì€ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.{RESET}")
                            continue
                    
                    index = int(user_input) - 1
                    if 0 <= index < len(unique_characters):
                        if index not in selected_indices:
                            selected_indices.append(index)
                            print(f"{GREEN}âœ“ {unique_characters[index]['name']} ì„ íƒë¨{RESET}")
                        else:
                            print(f"{YELLOW}ì´ë¯¸ ì„ íƒëœ ìºë¦­í„°ì…ë‹ˆë‹¤.{RESET}")
                    else:
                        print(f"{RED}ì˜¬ë°”ë¥¸ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (1-{len(unique_characters)}).{RESET}")
                        
                except ValueError:
                    print(f"{RED}ìˆ«ìë¥¼ ì…ë ¥í•˜ê±°ë‚˜ 'done'ì„ ì…ë ¥í•˜ì„¸ìš”.{RESET}")
                except KeyboardInterrupt:
                    print(f"\n{YELLOW}ì„ íƒì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.{RESET}")
                    return None
            
            # ì„ íƒëœ ìºë¦­í„°ë“¤ë¡œ íŒŒí‹° ìƒì„±
            party = []
            for index in selected_indices:
                char_info = unique_characters[index]
                try:
                    # ì €ì¥ëœ ë°ì´í„°ì—ì„œ ìºë¦­í„° ë³µì›
                    from game.save_system import GameStateSerializer
                    character = GameStateSerializer.deserialize_character(char_info['original_data'])
                    if character:
                        party.append(character)
                        print(f"{GREEN}âœ“ {character.name} ë¡œë“œ ì™„ë£Œ{RESET}")
                    else:
                        print(f"{RED}âœ— {char_info['name']} ë¡œë“œ ì‹¤íŒ¨{RESET}")
                except Exception as e:
                    print(f"{RED}âœ— {char_info['name']} ë¡œë“œ ì˜¤ë¥˜: {e}{RESET}")
                    continue
            
            if len(party) == 0:
                print(f"{RED}ìºë¦­í„°ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return None
            
            print(f"\n{BRIGHT_CYAN}ğŸ‰ ì €ì¥ëœ ìºë¦­í„° {len(party)}ëª…ìœ¼ë¡œ íŒŒí‹° êµ¬ì„± ì™„ë£Œ!{RESET}")
            return party
            
        except Exception as e:
            print(f"{RED}ì €ì¥ëœ ìºë¦­í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}{RESET}")
            return None
    
    def _give_starting_items_to_party(self, party_members: List[Character]):
        """íŒŒí‹° ì „ì²´ì—ê²Œ ìŠ¤íƒ€íŒ… ì•„ì´í…œ ì§€ê¸‰"""
        print(f"\n{CYAN}ğŸ ìŠ¤íƒ€íŒ… ì•„ì´í…œ ì§€ê¸‰ ì¤‘...{RESET}")
        
        for character in party_members:
            try:
                # ê° ìºë¦­í„°ì—ê²Œ ìŠ¤íƒ€íŒ… ì•„ì´í…œ ìƒì„±
                starting_items = enhanced_items.generate_starting_items(
                    character.character_class, character.level
                )
                
                # ì¸ë²¤í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
                if not hasattr(character, 'inventory'):
                    character.inventory = []
                
                # ì¥ë¹„ ì•„ì´í…œ ì¶”ê°€ (2ê°œ)
                for equipment in starting_items["equipment"]:
                    item = enhanced_items.create_item_for_inventory(equipment)
                    # ì¸ë²¤í† ë¦¬ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
                    if hasattr(character.inventory, 'add_item_by_name'):
                        # Inventory ê°ì²´ì¸ ê²½ìš° - ì´ë¦„ìœ¼ë¡œ ì¶”ê°€
                        success = character.inventory.add_item_by_name(item['name'])
                        if not success:
                            print(f"      âš ï¸ {item['name']} ì¶”ê°€ ì‹¤íŒ¨ (add_item_by_name)")
                    elif hasattr(character.inventory, 'add_item'):
                        # Inventory ê°ì²´ì¸ ê²½ìš° - ì§ì ‘ ì¶”ê°€ (fallback)
                        try:
                            from game.items import Item, ItemType, ItemRarity
                            inventory_item = Item(item['name'], ItemType.EQUIPMENT, ItemRarity.COMMON, 
                                                item.get('description', 'ì¥ë¹„ ì•„ì´í…œ'))
                            character.inventory.add_item(inventory_item)
                        except Exception as e:
                            print(f"      âš ï¸ {item['name']} ì¶”ê°€ ì‹¤íŒ¨ (add_item): {e}")
                    elif hasattr(character.inventory, 'items'):
                        # Dict í˜•íƒœ ì¸ë²¤í† ë¦¬ì¸ ê²½ìš°
                        if item['name'] in character.inventory.items:
                            character.inventory.items[item['name']] += item.get('quantity', 1)
                        else:
                            character.inventory.items[item['name']] = item.get('quantity', 1)
                    else:
                        # ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° - ì§ì ‘ ì¶”ê°€
                        character.inventory.append(item)
                
                # ì†Œë¹„ ì•„ì´í…œ ì¶”ê°€ (2ê°œ)
                for consumable in starting_items["consumables"]:
                    item = enhanced_items.create_item_for_inventory(consumable)
                    # ì¸ë²¤í† ë¦¬ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
                    if hasattr(character.inventory, 'add_item_by_name'):
                        # Inventory ê°ì²´ì¸ ê²½ìš° - ì´ë¦„ìœ¼ë¡œ ì¶”ê°€
                        success = character.inventory.add_item_by_name(item['name'])
                        if not success:
                            print(f"      âš ï¸ {item['name']} ì¶”ê°€ ì‹¤íŒ¨ (add_item_by_name)")
                    elif hasattr(character.inventory, 'add_item'):
                        # Inventory ê°ì²´ì¸ ê²½ìš° - ì§ì ‘ ì¶”ê°€ (fallback)
                        try:
                            from game.items import Item, ItemType, ItemRarity
                            inventory_item = Item(item['name'], ItemType.CONSUMABLE, ItemRarity.COMMON, 
                                                item.get('description', 'ì†Œë¹„ ì•„ì´í…œ'))
                            character.inventory.add_item(inventory_item)
                        except Exception as e:
                            print(f"      âš ï¸ {item['name']} ì¶”ê°€ ì‹¤íŒ¨ (add_item): {e}")
                    elif hasattr(character.inventory, 'items'):
                        # Dict í˜•íƒœ ì¸ë²¤í† ë¦¬ì¸ ê²½ìš°
                        if item['name'] in character.inventory.items:
                            character.inventory.items[item['name']] += item.get('quantity', 1)
                        else:
                            character.inventory.items[item['name']] = item.get('quantity', 1)
                    else:
                        # ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° - ì§ì ‘ ì¶”ê°€
                        character.inventory.append(item)
                
                # ìë™ ì¥ì°© ì‹œë„ (ì¥ë¹„ ì•„ì´í…œë§Œ)
                self._auto_equip_starting_items(character, starting_items["equipment"])
                
                print(f"{GREEN}  âœ… {character.name} - ìŠ¤íƒ€íŒ… ì•„ì´í…œ ì§€ê¸‰ ì™„ë£Œ{RESET}")
                
            except Exception as e:
                print(f"{RED}  âœ— {character.name} - ì•„ì´í…œ ì§€ê¸‰ ì‹¤íŒ¨: {e}{RESET}")

    def _calculate_diversity_score(self, party_classes: List[str]) -> int:
        """íŒŒí‹° êµ¬ì„±ì˜ ë‹¤ì–‘ì„± ì ìˆ˜ ê³„ì‚° (0-100ì )"""
        if not party_classes:
            return 0
        
        score = 0
        
        # 1. ì¤‘ë³µ ì—†ëŠ” ì§ì—… ë¹„ìœ¨ (40ì )
        unique_classes = len(set(party_classes))
        total_classes = len(party_classes)
        uniqueness_ratio = unique_classes / total_classes
        score += int(uniqueness_ratio * 40)
        
        # 2. ì—­í•  ë‹¤ì–‘ì„± (30ì )
        role_count = {"íƒ±ì»¤": 0, "ë”œëŸ¬": 0, "ë§ˆë²•ì‚¬": 0, "ì„œí¬í„°": 0, "í•˜ì´ë¸Œë¦¬ë“œ": 0}
        for class_name in party_classes:
            for role, classes in self.ROLE_CLASSES.items():
                if class_name in classes:
                    role_count[role] += 1
                    break
        
        # ì„œë¡œ ë‹¤ë¥¸ ì—­í• ì˜ ìˆ˜
        different_roles = sum(1 for count in role_count.values() if count > 0)
        role_diversity = (different_roles / 5) * 30  # ìµœëŒ€ 5ê°œ ì—­í• 
        score += int(role_diversity)
        
        # 3. í¬ì†Œ ì§ì—… ë³´ë„ˆìŠ¤ (20ì )
        rare_classes = ["ì•”ì‚´ì", "í•´ì ", "ì‚¬ë¬´ë¼ì´", "ë“œë£¨ì´ë“œ", "ì² í•™ì", 
                       "ê²€íˆ¬ì‚¬", "ê¸°ì‚¬", "ì‹ ê´€", "ê´‘ì „ì‚¬"]
        rare_count = sum(1 for class_name in party_classes if class_name in rare_classes)
        rare_bonus = min(20, rare_count * 7)  # í¬ì†Œ ì§ì—… 1ê°œë‹¹ 7ì , ìµœëŒ€ 20ì 
        score += rare_bonus
        
        # 4. ë°¸ëŸ°ìŠ¤ í˜ë„í‹° (í•œ ì—­í• ì´ ë„ˆë¬´ ë§ìœ¼ë©´ ê°ì )
        balance_penalty = 0
        for role, count in role_count.items():
            if count > 2:  # ê°™ì€ ì—­í• ì´ 3ëª… ì´ìƒì´ë©´ í˜ë„í‹°
                balance_penalty += (count - 2) * 5
        
        # 5. í•˜ì´ë¸Œë¦¬ë“œ ì§ì—… íŠ¹ë³„ ë³´ë„ˆìŠ¤ (10ì )
        hybrid_bonus = min(10, role_count["í•˜ì´ë¸Œë¦¬ë“œ"] * 10)
        score += hybrid_bonus
        
        final_score = max(0, min(100, score - balance_penalty))
        
        return final_score
    
    def _auto_equip_starting_items(self, character: Character, equipment_items: List[Dict]):
        """ìŠ¤íƒ€íŒ… ì¥ë¹„ ìë™ ì¥ì°©"""
        for equipment in equipment_items:
            try:
                # ì¥ë¹„ íƒ€ì… í™•ì¸
                item_type = self._determine_equipment_type(equipment)
                item_name = equipment.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì•„ì´í…œ')
                
                # ìºë¦­í„°ì— ì¥ë¹„ ì†ì„±ì´ ì—†ìœ¼ë©´ ìƒì„±
                if not hasattr(character, 'weapon'):
                    character.weapon = None
                if not hasattr(character, 'armor'):
                    character.armor = None
                if not hasattr(character, 'accessory'):
                    character.accessory = None
                
                # í•´ë‹¹ ìŠ¬ë¡¯ì´ ë¹„ì–´ìˆìœ¼ë©´ ìë™ ì¥ì°©
                if item_type == "ë¬´ê¸°" and character.weapon is None:
                    character.weapon = equipment
                    print(f"{GREEN}      âœ… {item_name} ë¬´ê¸° ìŠ¬ë¡¯ì— ìë™ ì¥ì°©{RESET}")
                elif item_type == "ë°©ì–´êµ¬" and character.armor is None:
                    character.armor = equipment
                    print(f"{GREEN}      âœ… {item_name} ë°©ì–´êµ¬ ìŠ¬ë¡¯ì— ìë™ ì¥ì°©{RESET}")
                elif item_type == "ì¥ì‹ êµ¬" and character.accessory is None:
                    character.accessory = equipment
                    print(f"{GREEN}      âœ… {item_name} ì¥ì‹ êµ¬ ìŠ¬ë¡¯ì— ìë™ ì¥ì°©{RESET}")
                else:
                    print(f"{YELLOW}      âš ï¸ {item_name} ({item_type}) - í•´ë‹¹ ìŠ¬ë¡¯ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘{RESET}")
                    
            except Exception as e:
                print(f"{YELLOW}    âš ï¸ {equipment.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì•„ì´í…œ')} ìë™ ì¥ì°© ì‹¤íŒ¨: {e}{RESET}")
    
    def _determine_equipment_type(self, equipment: Dict) -> str:
        """ì¥ë¹„ íƒ€ì… íŒë³„"""
        name = equipment.get('name', '').lower()
        
        # ë¬´ê¸° í‚¤ì›Œë“œ
        weapon_keywords = ['ê²€', 'ë„', 'í™œ', 'ì§€íŒ¡ì´', 'ì°½', 'ë„ë¼', 'ë§ì¹˜', 'ë‹¨ê²€', 'ì´', 'ê¶Œì´', 'ì†Œì´']
        # ë°©ì–´êµ¬ í‚¤ì›Œë“œ  
        armor_keywords = ['ê°‘ì˜·', 'ë¡œë¸Œ', 'ê°€ì£½', 'ì²œ', 'íŒê¸ˆ', 'ì‚¬ìŠ¬', 'íˆ¬êµ¬', 'ëª¨ì', 'ë°©íŒ¨']
        # ì¥ì‹ êµ¬ í‚¤ì›Œë“œ
        accessory_keywords = ['ë°˜ì§€', 'ëª©ê±¸ì´', 'íŒ”ì°Œ', 'ë¶€ì ', 'ì¥ì‹ êµ¬']
        
        for keyword in weapon_keywords:
            if keyword in name:
                return "ë¬´ê¸°"
        
        for keyword in armor_keywords:
            if keyword in name:
                return "ë°©ì–´êµ¬"
                
        for keyword in accessory_keywords:
            if keyword in name:
                return "ì¥ì‹ êµ¬"
        
        # ê¸°ë³¸ê°’ì€ ë¬´ê¸°ë¡œ ì²˜ë¦¬
        return "ë¬´ê¸°"
    
    def _manual_select_passives(self, character: Character):
        """ì‚¬ìš©ìê°€ ì§ì ‘ íŠ¹ì„± ì„ íƒ - ì»¤ì„œ ë©”ë‰´ ë°©ì‹"""
        print(f"\n{CYAN}=== {character.name}({character.character_class})ì˜ íŠ¹ì„± ì„ íƒ ==={RESET}")
        
        # íŠ¹ì„± ì‹œìŠ¤í…œì´ ìˆëŠ”ì§€ í™•ì¸
        try:
            from game.character import CharacterClassManager
            from game.cursor_menu_system import CursorMenu
            
            available_traits = CharacterClassManager.get_class_traits(character.character_class)
            
            if not available_traits:
                print(f"{YELLOW}ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return
            
            # ì»¤ì„œ ë©”ë‰´ìš© ì˜µì…˜ êµ¬ì„±
            options = []
            for trait in available_traits:
                options.append({
                    'text': trait.name,
                    'detail': trait.description
                })
            
            # ê±´ë„ˆë›°ê¸° ì˜µì…˜ ì¶”ê°€
            options.append({
                'text': 'íŠ¹ì„± ì—†ì´ ê³„ì†',
                'detail': 'íŠ¹ì„±ì„ ì„ íƒí•˜ì§€ ì•Šê³  ì§„í–‰í•©ë‹ˆë‹¤'
            })
            
            # ì»¤ì„œ ë©”ë‰´ í‘œì‹œ
            menu = CursorMenu(
                title=f"{character.name}ì˜ íŠ¹ì„± ì„ íƒ",
                options=options,
                descriptions=[opt['detail'] for opt in options],
                screen_width=100,
                screen_height=30
            )
            
            choice = menu.display()
            
            if choice < len(available_traits):
                selected_trait = available_traits[choice]
                character.traits = [selected_trait]
                print(f"\n{GREEN}âœ… '{selected_trait.name}' íŠ¹ì„±ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
            else:
                print(f"\n{CYAN}íŠ¹ì„± ì„ íƒì„ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.{RESET}")
                    
        except Exception as e:
            print(f"{YELLOW}íŠ¹ì„± ì‹œìŠ¤í…œì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}{RESET}")
            print(f"{CYAN}íŠ¹ì„± ì—†ì´ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.{RESET}")
    
    def _provide_starting_equipment(self, character: Character):
        """ìºë¦­í„°ì—ê²Œ ì‹œì‘ ì¥ë¹„ ì œê³µ"""
        try:
            # ì‹œì‘ ì•„ì´í…œ ìƒì„± (ëœë¤ 2ê°œ ì¥ë¹„ + 1-3ê°œ ì†Œëª¨í’ˆ)
            starting_items = self._generate_starting_items_for_class(character.character_class)
            
            if starting_items:
                print(f"\n{GREEN}âœ… {character.name}ì—ê²Œ ì‹œì‘ ì¥ë¹„ë¥¼ ì œê³µí•©ë‹ˆë‹¤:{RESET}")
                
                # ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™” (ì—†ëŠ” ê²½ìš°)
                if not hasattr(character, 'inventory') or character.inventory is None:
                    from game.items import Inventory
                    character.inventory = Inventory()
                
                # ì¥ë¹„ ì•„ì´í…œ ì¶”ê°€ ë° ìë™ ì¥ì°©
                equipment_for_auto_equip = []
                for item in starting_items.get("equipment", []):
                    # Item ê°ì²´ë¡œ ë³€í™˜í•˜ì—¬ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
                    from game.items import Item, ItemType, ItemRarity
                    
                    # ì•„ì´í…œ íƒ€ì… ê²°ì •
                    item_type_str = item.get('type', 'ì¥ë¹„')
                    if item_type_str == 'ë¬´ê¸°':
                        item_type = ItemType.WEAPON
                    elif item_type_str == 'ë°©ì–´êµ¬':
                        item_type = ItemType.ARMOR
                    elif item_type_str == 'ì¥ì‹ êµ¬':
                        item_type = ItemType.ACCESSORY
                    else:
                        item_type = ItemType.WEAPON  # ê¸°ë³¸ê°’
                    
                    item_obj = Item(
                        name=item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì¥ë¹„'),
                        item_type=item_type,
                        rarity=ItemRarity.COMMON,
                        description=f"{character.character_class} ì „ìš© ì‹œì‘ ì¥ë¹„",
                        weight=1.0,
                        value=10
                    )
                    
                    # ì•„ì´í…œ ìŠ¤íƒ¯ ì„¤ì •
                    if item.get('attack'):
                        item_obj.stats['ê³µê²©ë ¥'] = item['attack']
                    if item.get('defense'):
                        item_obj.stats['ë°©ì–´ë ¥'] = item['defense']
                    
                    if character.inventory.add_item(item_obj):
                        print(f"  ğŸ“¦ {item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì¥ë¹„')} íšë“!")
                        equipment_for_auto_equip.append(item)
                    else:
                        print(f"  âŒ {item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì¥ë¹„')} ì¶”ê°€ ì‹¤íŒ¨ (ì¸ë²¤í† ë¦¬ ê°€ë“ì°¸)")
                
                # ì†Œëª¨í’ˆ ì¶”ê°€
                for item in starting_items.get("consumables", []):
                    from game.items import Item, ItemType, ItemRarity
                    item_obj = Item(
                        name=item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì†Œëª¨í’ˆ'),
                        item_type=ItemType.CONSUMABLE,
                        rarity=ItemRarity.COMMON,
                        description=f"ìœ ìš©í•œ ì†Œëª¨í’ˆ",
                        weight=0.1,
                        value=5
                    )
                    
                    if character.inventory.add_item(item_obj):
                        print(f"  ğŸ§ª {item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì†Œëª¨í’ˆ')} íšë“!")
                    else:
                        print(f"  âŒ {item.get('name', 'ì•Œ ìˆ˜ ì—†ëŠ” ì†Œëª¨í’ˆ')} ì¶”ê°€ ì‹¤íŒ¨ (ì¸ë²¤í† ë¦¬ ê°€ë“í•¨)")
                
                # ìë™ ì¥ì°© ì‹œë„
                if equipment_for_auto_equip:
                    self._auto_equip_starting_items(character, equipment_for_auto_equip)
                
            else:
                print(f"{YELLOW}âš ï¸ {character.character_class}ì— ëŒ€í•œ ì‹œì‘ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                
        except Exception as e:
            print(f"{YELLOW}âš ï¸ ì‹œì‘ ì¥ë¹„ ì œê³µ ì¤‘ ì˜¤ë¥˜: {e}{RESET}")
            import traceback
            traceback.print_exc()
    
    def _generate_starting_items_for_class(self, character_class: str) -> Dict[str, List[Dict]]:
        """ì§ì—…ë³„ ì‹œì‘ ì•„ì´í…œ ìƒì„± (2ê°œ ì¥ë¹„ + 1-3ê°œ ì†Œëª¨í’ˆ)"""
        import random
        
        # ì§ì—…ë³„ ì¥ë¹„ ì¹´í…Œê³ ë¦¬ ë§¤í•‘
        class_equipment_map = {
            # ì „íˆ¬ ì§ì—…êµ°
            "ì „ì‚¬": {"weapon": ["ê²€", "ë„ë¼", "ë§ì¹˜"], "armor": ["íŒê¸ˆê°‘ì˜·", "ì‚¬ìŠ¬ê°‘ì˜·"], "accessory": ["ì „ì‚¬ì˜ ë°˜ì§€"]},
            "ì•„í¬ë©”ì´ì§€": {"weapon": ["ì§€íŒ¡ì´", "ì™„ë“œ"], "armor": ["ë§ˆë²•ì‚¬ ë¡œë¸Œ"], "accessory": ["ë§ˆë ¥ì˜ ëª©ê±¸ì´"]},
            "ê¶ìˆ˜": {"weapon": ["í™œ", "ì„ê¶"], "armor": ["ê°€ì£½ê°‘ì˜·"], "accessory": ["ì •í™•ì„±ì˜ ë°˜ì§€"]},
            "ë„ì ": {"weapon": ["ë‹¨ê²€", "ë‹¨ê²€"], "armor": ["ê²½ëŸ‰ê°‘ì˜·"], "accessory": ["ë¯¼ì²©ì˜ ë°˜ì§€"]},
            "ì„±ê¸°ì‚¬": {"weapon": ["ì„±ê²€", "ì„±ìŠ¤ëŸ¬ìš´ ì°½"], "armor": ["ì„±ê¸°ì‚¬ ê°‘ì˜·"], "accessory": ["ì„±ìŠ¤ëŸ¬ìš´ ëª©ê±¸ì´"]},
            "ì•”í‘ê¸°ì‚¬": {"weapon": ["ì•”í‘ê²€", "ì €ì£¼ë°›ì€ ë„ë¼"], "armor": ["ì•”í‘ê°‘ì˜·"], "accessory": ["ì–´ë‘ ì˜ ë°˜ì§€"]},
            "ëª½í¬": {"weapon": ["ê¶Œíˆ¬ê¸€ëŸ¬ë¸Œ", "ì² ì œ ê±´í‹€ë¦¿"], "armor": ["ìˆ˜ë„ë³µ"], "accessory": ["ì§‘ì¤‘ì˜ íŒ”ì°Œ"]},
            "ë°”ë“œ": {"weapon": ["í•˜í”„", "ë¥˜íŠ¸"], "armor": ["ìŒìœ ì‹œì¸ ì˜·"], "accessory": ["ìŒì•…ì˜ ë°˜ì§€"]},
            
            # ë§ˆë²• ì§ì—…êµ°
            "ë„¤í¬ë¡œë§¨ì„œ": {"weapon": ["í•´ê³¨ ì§€íŒ¡ì´", "ë¶€íŒ¨ì˜ ì™„ë“œ"], "armor": ["ë„¤í¬ë¡œë§¨ì„œ ë¡œë¸Œ"], "accessory": ["ì–¸ë°ë“œì˜ ëª©ê±¸ì´"]},
            "ìš©ê¸°ì‚¬": {"weapon": ["ìš©ê²€", "ë“œë˜ê³¤ ì°½"], "armor": ["ìš©ë¹„ëŠ˜ ê°‘ì˜·"], "accessory": ["ìš©ì˜ ì‹¬ì¥"]},
            "ê²€ì„±": {"weapon": ["ì˜ê²€", "ê¸°ê²€"], "armor": ["ê²€ì„± ë„ë³µ"], "accessory": ["ê²€ê¸°ì˜ ë°˜ì§€"]},
            "ì •ë ¹ìˆ ì‚¬": {"weapon": ["ì •ë ¹ ì§€íŒ¡ì´", "ì›ì†Œ ì™„ë“œ"], "armor": ["ì •ë ¹ìˆ ì‚¬ ë¡œë¸Œ"], "accessory": ["ì›ì†Œì˜ ëª©ê±¸ì´"]},
            "ì‹œê°„ìˆ ì‚¬": {"weapon": ["ì‹œê³µ ì§€íŒ¡ì´", "ì‹œê°„ì˜ ì™„ë“œ"], "armor": ["ì‹œê°„ìˆ ì‚¬ ë¡œë¸Œ"], "accessory": ["ì‹œê°„ì˜ ë°˜ì§€"]},
            "ì—°ê¸ˆìˆ ì‚¬": {"weapon": ["ì—°ê¸ˆìˆ  ì§€íŒ¡ì´", "ì‹¤í—˜ ë„êµ¬"], "armor": ["ì—°ê¸ˆìˆ ì‚¬ ì½”íŠ¸"], "accessory": ["ì—°ê¸ˆì˜ ë°˜ì§€"]},
            "ì°¨ì›ìˆ ì‚¬": {"weapon": ["ì°¨ì› ì§€íŒ¡ì´", "ê³µê°„ ì™„ë“œ"], "armor": ["ì°¨ì›ìˆ ì‚¬ ë¡œë¸Œ"], "accessory": ["ì°¨ì›ì˜ ëª©ê±¸ì´"]},
            "ë§ˆê²€ì‚¬": {"weapon": ["ë§ˆê²€", "ë§ˆë„ê²€"], "armor": ["ë§ˆê²€ì‚¬ ê°‘ì˜·"], "accessory": ["ë§ˆë ¥ì˜ ë°˜ì§€"]},
            "ê¸°ê³„ê³µí•™ì": {"weapon": ["ê¸°ê³„ ê¶Œì´", "ë ˆì´ì € ê±´"], "armor": ["ê¸°ê³„ ê°‘ì˜·"], "accessory": ["ê¸°ê³„ì˜ íŒ”ì°Œ"]},
            "ë¬´ë‹¹": {"weapon": ["ì˜í˜¼ ì§€íŒ¡ì´", "ì œë¡€ìš© ì¹¼"], "armor": ["ë¬´ë‹¹ ì˜ë³µ"], "accessory": ["ì˜í˜¼ì˜ ëª©ê±¸ì´"]},
            
            # íŠ¹ìˆ˜ ì§ì—…êµ°
            "ì•”ì‚´ì": {"weapon": ["ì•”ì‚´ ë‹¨ê²€", "ë… ì¹¼"], "armor": ["ì•”ì‚´ì ì˜ë³µ"], "accessory": ["ê·¸ë¦¼ìì˜ ë°˜ì§€"]},
            "í•´ì ": {"weapon": ["í•´ì  ë„", "ê³¡ë„"], "armor": ["í•´ì  ì½”íŠ¸"], "accessory": ["í•´ì ì˜ ëª©ê±¸ì´"]},
            "ì‚¬ë¬´ë¼ì´": {"weapon": ["ì¹´íƒ€ë‚˜", "ì™€í‚¤ìì‹œ"], "armor": ["ì‚¬ë¬´ë¼ì´ ê°‘ì˜·"], "accessory": ["ëª…ì˜ˆì˜ ë°˜ì§€"]},
            "ë“œë£¨ì´ë“œ": {"weapon": ["ìì—° ì§€íŒ¡ì´", "ë‚˜ë¬´ ì°½"], "armor": ["ë“œë£¨ì´ë“œ ë¡œë¸Œ"], "accessory": ["ìì—°ì˜ ëª©ê±¸ì´"]},
            "ì² í•™ì": {"weapon": ["ì§€í˜œì˜ ì§€íŒ¡ì´", "ë…¼ë¦¬ì˜ ì™„ë“œ"], "armor": ["ì² í•™ì ë¡œë¸Œ"], "accessory": ["ì§€í˜œì˜ ë°˜ì§€"]},
            "ê²€íˆ¬ì‚¬": {"weapon": ["ê¸€ë¼ë””ìš°ìŠ¤", "íŠ¸ë¼ì´ë˜íŠ¸"], "armor": ["ê²€íˆ¬ì‚¬ ê°‘ì˜·"], "accessory": ["íˆ¬ê¸°ì˜ ë°˜ì§€"]},
            "ê¸°ì‚¬": {"weapon": ["ê¸°ì‚¬ ì°½", "ë¡±ì†Œë“œ"], "armor": ["ê¸°ì‚¬ ê°‘ì˜·"], "accessory": ["ê¸°ì‚¬ì˜ ë°˜ì§€"]},
            "ì‹ ê´€": {"weapon": ["ì„±ìŠ¤ëŸ¬ìš´ ë©”ì´ìŠ¤", "ì¶•ë³µì˜ ì§€íŒ¡ì´"], "armor": ["ì‹ ê´€ ë¡œë¸Œ"], "accessory": ["ì‹ ì„±ì˜ ëª©ê±¸ì´"]},
            "ê´‘ì „ì‚¬": {"weapon": ["ê´‘ì „ì‚¬ ë„ë¼", "íŒŒê´´ì˜ ë§ì¹˜"], "armor": ["ê´‘ì „ì‚¬ ê°‘ì˜·"], "accessory": ["ê´‘ê¸°ì˜ ë°˜ì§€"]}
        }
        
        # ê³µí†µ ì†Œëª¨í’ˆ
        consumables = [
            {"name": "ì²´ë ¥ í¬ì…˜", "type": "ì†Œëª¨í’ˆ", "effect": "HP íšŒë³µ", "value": 50},
            {"name": "ë§ˆë‚˜ í¬ì…˜", "type": "ì†Œëª¨í’ˆ", "effect": "MP íšŒë³µ", "value": 30},
            {"name": "í•´ë…ì œ", "type": "ì†Œëª¨í’ˆ", "effect": "ë… ì¹˜ë£Œ", "value": 1},
            {"name": "ìƒì²˜ ì—°ê³ ", "type": "ì†Œëª¨í’ˆ", "effect": "ìƒì²˜ ì¹˜ë£Œ", "value": 25},
            {"name": "í˜ì˜ ë¬¼ì•½", "type": "ì†Œëª¨í’ˆ", "effect": "ê³µê²©ë ¥ ì¦ê°€", "value": 10}
        ]
        
        # ì§ì—…ì— ë§ëŠ” ì¥ë¹„ ì„ íƒ
        equipment_data = class_equipment_map.get(character_class, class_equipment_map["ì „ì‚¬"])
        starting_equipment = []
        
        # ë¬´ê¸° 1ê°œ ëœë¤ ì„ íƒ
        if equipment_data.get("weapon"):
            weapon_name = random.choice(equipment_data["weapon"])
            starting_equipment.append({
                "name": weapon_name,
                "type": "ë¬´ê¸°",
                "attack": random.randint(8, 15),
                "durability": 100,
                "class_specific": character_class
            })
        
        # ë°©ì–´êµ¬ 1ê°œ ëœë¤ ì„ íƒ
        if equipment_data.get("armor"):
            armor_name = random.choice(equipment_data["armor"])
            starting_equipment.append({
                "name": armor_name,
                "type": "ë°©ì–´êµ¬", 
                "defense": random.randint(5, 12),
                "durability": 100,
                "class_specific": character_class
            })
        
        # ì†Œëª¨í’ˆ 1-3ê°œ ëœë¤ ì„ íƒ
        starting_consumables = random.sample(consumables, random.randint(1, 3))
        
        return {
            "equipment": starting_equipment,
            "consumables": starting_consumables
        }
    
    def _ai_assisted_select_passives(self, character: Character, user_tags: List[str]):
        """AI íŒíŠ¸ì™€ í•¨ê»˜ íŠ¹ì„± ì„ íƒ"""
        print(f"\n{CYAN}=== {character.name}({character.character_class})ì˜ íŠ¹ì„± ì„ íƒ (AI ì¶”ì²œ) ==={RESET}")
        
        try:
            from game.character import CharacterClassManager
            available_traits = CharacterClassManager.get_class_traits(character.character_class)
            
            if not available_traits:
                print(f"{YELLOW}ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return
            
            # AI ì¶”ì²œ ì ìˆ˜ ê³„ì‚°
            trait_scores = {}
            for trait in available_traits:
                score = self._calculate_trait_ai_score(trait, user_tags)
                trait_scores[trait.name] = score
            
            # ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
            sorted_traits = sorted(available_traits, key=lambda t: trait_scores[t.name], reverse=True)
            
            print(f"{GREEN}AI ì¶”ì²œ íŠ¹ì„± (ì¶”ì²œë„ ìˆœ):{RESET}")
            for i, trait in enumerate(sorted_traits):
                score = trait_scores[trait.name]
                stars = "â˜…" * min(5, max(1, int(score / 20)))
                print(f"  [{i+1}] {trait.name}: {trait.description}")
                print(f"      {YELLOW}AI ì¶”ì²œë„: {stars} ({score:.0f}ì ){RESET}")
            
            print(f"\n{YELLOW}íŠ¹ì„±ì„ ì„ íƒí•˜ì„¸ìš” (1-{len(sorted_traits)}, 0=AI ìë™ ì„ íƒ):{RESET}")
            
            while True:
                try:
                    choice = input("íŠ¹ì„± ë²ˆí˜¸: ").strip()
                    if choice == "0" or choice == "":
                        # AI ìë™ ì„ íƒ (ê°€ì¥ ë†’ì€ ì ìˆ˜)
                        selected_trait = sorted_traits[0]
                        character.traits = [selected_trait]
                        print(f"{GREEN}ğŸ¤– AIê°€ '{selected_trait.name}'ì„(ë¥¼) ìë™ ì„ íƒí–ˆìŠµë‹ˆë‹¤!{RESET}")
                        break
                    
                    trait_index = int(choice) - 1
                    if 0 <= trait_index < len(sorted_traits):
                        selected_trait = sorted_traits[trait_index]
                        character.traits = [selected_trait]
                        print(f"{GREEN}âœ… '{selected_trait.name}' íŠ¹ì„±ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
                        break
                    else:
                        print(f"{RED}ì˜ëª»ëœ ë²ˆí˜¸ì…ë‹ˆë‹¤. 1-{len(sorted_traits)} ì‚¬ì´ì˜ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.{RESET}")
                        
                except ValueError:
                    print(f"{RED}ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.{RESET}")
                except KeyboardInterrupt:
                    print(f"\n{YELLOW}íŠ¹ì„± ì„ íƒì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.{RESET}")
                    break
                    
        except Exception as e:
            print(f"{YELLOW}íŠ¹ì„± ì‹œìŠ¤í…œì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}{RESET}")
            print(f"{CYAN}íŠ¹ì„± ì—†ì´ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.{RESET}")
    
    def _calculate_trait_ai_score(self, trait: 'CharacterTrait', user_tags: List[str]) -> float:
        """íŠ¹ì„±ì— ëŒ€í•œ AI ì¶”ì²œ ì ìˆ˜ ê³„ì‚°"""
        score = 50.0  # ê¸°ë³¸ ì ìˆ˜
        
        # ì‚¬ìš©ì íƒœê·¸ì— ë”°ë¥¸ ì ìˆ˜ ì¡°ì •
        trait_name_lower = trait.name.lower()
        trait_desc_lower = trait.description.lower()
        
        for tag in user_tags:
            tag_lower = tag.lower()
            
            # íƒœê·¸ì™€ íŠ¹ì„± ì´ë¦„/ì„¤ëª… ë§¤ì¹­
            if tag_lower in trait_name_lower or tag_lower in trait_desc_lower:
                score += 30
            
            # íŠ¹ì • íƒœê·¸ì— ë”°ë¥¸ ì¶”ê°€ ì ìˆ˜
            if tag == "ê³µê²©ì " and ("ê³µê²©" in trait_desc_lower or "í”¼í•´" in trait_desc_lower):
                score += 25
            elif tag == "ë°©ì–´ì " and ("ë°©ì–´" in trait_desc_lower or "ë³´í˜¸" in trait_desc_lower):
                score += 25
            elif tag == "ì „ëµì " and ("ìŠ¤íƒ" in trait_desc_lower or "íš¨ê³¼" in trait_desc_lower):
                score += 20
            elif tag == "í˜‘ë ¥ì " and ("ì•„êµ°" in trait_desc_lower or "íŒŒí‹°" in trait_desc_lower):
                score += 20
        
        # íŠ¹ì„± íƒ€ì…ì— ë”°ë¥¸ ê¸°ë³¸ ì ìˆ˜
        if hasattr(trait, 'effect_type'):
            if trait.effect_type == "passive":
                score += 10  # íŒ¨ì‹œë¸ŒëŠ” í•­ìƒ ìœ ìš©
            elif trait.effect_type == "trigger":
                score += 15  # íŠ¸ë¦¬ê±°ëŠ” ë” ê°•ë ¥
        
        return min(100, max(0, score))
    
    def _allow_name_customization(self, character: Character):
        """ìºë¦­í„° ì´ë¦„ ì»¤ìŠ¤í„°ë§ˆì´ì§• - ì´ë¦„ í’€ì—ì„œ ì„ íƒ"""
        print(f"\n{CYAN}=== ìºë¦­í„° ì´ë¦„ ì„¤ì • ==={RESET}")
        print(f"í˜„ì¬ ì´ë¦„: {GREEN}{character.name}{RESET} ({character.character_class})")
        
        try:
            from game.unified_name_pools import NAME_POOLS, get_random_name, detect_gender_from_name
            from game.cursor_menu_system import CursorMenu
            import random
            
            # í˜„ì¬ ì´ë¦„ìœ¼ë¡œ ì„±ë³„ ê°ì§€
            current_gender = detect_gender_from_name(character.name)
            
            # ê°™ì€ ì„±ë³„ ì´ë¦„ë“¤ë§Œ 15ê°œ ì„ íƒ
            same_gender_names = random.sample(NAME_POOLS["western"][current_gender], min(15, len(NAME_POOLS["western"][current_gender])))
            
            # ì»¤ì„œ ë©”ë‰´ ì˜µì…˜ êµ¬ì„±
            options = []
            
            # í˜„ì¬ ì´ë¦„ ìœ ì§€ ì˜µì…˜
            options.append({
                'text': f'í˜„ì¬ ì´ë¦„ ìœ ì§€: {character.name}',
                'detail': f'{character.character_class}ì—ê²Œ ì–´ìš¸ë¦¬ëŠ” í˜„ì¬ ì´ë¦„ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤'
            })
            
            # ê°™ì€ ì„±ë³„ ì´ë¦„ë“¤
            for name in same_gender_names:
                if name != character.name:  # í˜„ì¬ ì´ë¦„ê³¼ ë‹¤ë¥¸ ê²ƒë§Œ
                    options.append({
                        'text': f'{name}',
                        'detail': f'{character.character_class}ì—ê²Œ ì–´ìš¸ë¦¬ëŠ” {current_gender} ì´ë¦„ì…ë‹ˆë‹¤'
                    })
            
            # ëœë¤ ë¦¬ë¡¤ ì˜µì…˜
            options.append({
                'text': 'ğŸ² ë‹¤ë¥¸ ì´ë¦„ë“¤ ë³´ê¸°',
                'detail': 'ìƒˆë¡œìš´ ëœë¤ ì´ë¦„ ëª©ë¡ì„ ë‹¤ì‹œ ìƒì„±í•©ë‹ˆë‹¤'
            })
            
            # ì§ì ‘ ì…ë ¥ ì˜µì…˜
            options.append({
                'text': 'âœï¸ ì§ì ‘ ì…ë ¥',
                'detail': 'ì›í•˜ëŠ” ì´ë¦„ì„ ì§ì ‘ ì…ë ¥í•©ë‹ˆë‹¤'
            })
            
            while True:
                # ì»¤ì„œ ë©”ë‰´ í‘œì‹œ
                menu = CursorMenu(
                    title=f"{character.name}ì˜ ì´ë¦„ ì„ íƒ",
                    options=options,
                    descriptions=[opt['detail'] for opt in options],
                    screen_width=100,
                    screen_height=25
                )
                
                choice = menu.display()
                
                if choice == 0:  # í˜„ì¬ ì´ë¦„ ìœ ì§€
                    print(f"{CYAN}ê¸°ì¡´ ì´ë¦„ '{character.name}'ì„ ìœ ì§€í•©ë‹ˆë‹¤.{RESET}")
                    break
                elif choice == len(options) - 2:  # ë¦¬ë¡¤
                    # ìƒˆë¡œìš´ ì´ë¦„ ëª©ë¡ ìƒì„±
                    same_gender_names = random.sample(NAME_POOLS["western"][current_gender], min(15, len(NAME_POOLS["western"][current_gender])))
                    
                    # ì˜µì…˜ ë‹¤ì‹œ êµ¬ì„± (ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ë‘ ê°œëŠ” ê³ ì •)
                    options = options[:1] + options[-2:]  # ì²« ë²ˆì§¸, ë¦¬ë¡¤, ì§ì ‘ì…ë ¥ë§Œ ìœ ì§€
                    
                    # ìƒˆ ì´ë¦„ë“¤ ì¶”ê°€
                    new_options = []
                    for name in same_gender_names:
                        if name != character.name:
                            new_options.append({
                                'text': f'{name}',
                                'detail': f'{character.character_class}ì—ê²Œ ì–´ìš¸ë¦¬ëŠ” {current_gender} ì´ë¦„ì…ë‹ˆë‹¤'
                            })
                    
                    # ìƒˆ ì˜µì…˜ë“¤ì„ ì¤‘ê°„ì— ì‚½ì…
                    options = options[:1] + new_options + options[1:]
                    print(f"{GREEN}ğŸ² ìƒˆë¡œìš´ ì´ë¦„ ëª©ë¡ì„ ìƒì„±í–ˆìŠµë‹ˆë‹¤!{RESET}")
                    continue
                    
                elif choice == len(options) - 1:  # ì§ì ‘ ì…ë ¥
                    print(f"{YELLOW}ìƒˆë¡œìš´ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:{RESET}")
                    new_name = input("ìƒˆ ì´ë¦„: ").strip()
                    if new_name and new_name != character.name:
                        character.name = new_name
                        print(f"{GREEN}âœ… ì´ë¦„ì´ '{new_name}'ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
                        break
                    else:
                        print(f"{YELLOW}ì˜¬ë°”ë¥¸ ì´ë¦„ì„ ì…ë ¥í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.{RESET}")
                        continue
                        
                else:  # ì´ë¦„ ì„ íƒ
                    selected_option = options[choice]
                    # ì´ë¦„ ì¶”ì¶œ
                    new_name = selected_option['text']
                    if new_name != character.name:
                        character.name = new_name
                        print(f"{GREEN}âœ… ì´ë¦„ì´ '{new_name}'ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
                    else:
                        print(f"{CYAN}ê¸°ì¡´ ì´ë¦„ì„ ìœ ì§€í•©ë‹ˆë‹¤.{RESET}")
                    break
            
        except KeyboardInterrupt:
            print(f"\n{CYAN}ì´ë¦„ ë³€ê²½ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.{RESET}")
        except Exception as e:
            print(f"{YELLOW}ì´ë¦„ ì„ íƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}{RESET}")
            print(f"{CYAN}ê¸°ì¡´ ì´ë¦„ì„ ìœ ì§€í•©ë‹ˆë‹¤.{RESET}")
    
    def create_random_party(self, party_size: int = 4) -> List[Character]:
        """ì™„ì „ ëœë¤ íŒŒí‹° ìƒì„±"""
        print(f"\n{CYAN}=== ëœë¤ íŒŒí‹° ìƒì„± ì‹œì‘ ==={RESET}")
        
        # ì‚¬ìš©ëœ ì´ë¦„ ì´ˆê¸°í™”
        self._used_names = set()
        
        # ëœë¤ìœ¼ë¡œ ì§ì—… ì„ íƒ
        import random
        selected_classes = random.sample(self.ALL_CLASSES, min(party_size, len(self.ALL_CLASSES)))
        
        print(f"{GREEN}ëœë¤ ì„ íƒëœ ì§ì—…ë“¤: {', '.join(selected_classes)}{RESET}")
        
        party_members = []
        
        for i, class_name in enumerate(selected_classes):
            character = self._create_character(class_name, i + 1)
            
            # ëœë¤ìœ¼ë¡œ íŠ¹ì„± ì„ íƒ (50% í™•ë¥ )
            if random.choice([True, False]):
                self._auto_select_passives(character)
            
            # ì‹œì‘ ì¥ë¹„ ì œê³µ
            self._provide_starting_equipment(character)
            
            party_members.append(character)
        
        print(f"{GREEN}âœ… ëœë¤ íŒŒí‹° ìƒì„± ì™„ë£Œ!{RESET}")
        return party_members
    
    def _manual_select_passives_with_ai_hints(self, character: Character, user_tags: List[str], trait_scores: Dict[str, int]):
        """AI íŒíŠ¸ì™€ í•¨ê»˜ ì‚¬ìš©ìê°€ ì§ì ‘ íŠ¹ì„± ì„ íƒ - ì»¤ì„œ ë©”ë‰´ ë°©ì‹"""
        print(f"\n{CYAN}=== {character.name}({character.character_class})ì˜ íŠ¹ì„± ì„ íƒ ==={RESET}")
        
        try:
            from game.trait_system import get_trait_system
            from game.cursor_menu_system import CursorMenu
            trait_system = get_trait_system()
            available_traits = trait_system.get_available_traits(character.character_class)
            
            if not available_traits:
                print(f"{YELLOW}ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ì„±ì´ ì—†ìŠµë‹ˆë‹¤.{RESET}")
                return
            
            # AI ì¶”ì²œ íŠ¹ì„± ê³„ì‚°
            recommended_traits = []
            for trait in available_traits:
                trait_name = trait.get('name', '')
                if trait_name in trait_scores:
                    recommended_traits.append((trait, trait_scores[trait_name]))
            
            # ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
            recommended_traits.sort(key=lambda x: x[1], reverse=True)
            recommended_trait_names = [t[0].get('name', '') for t in recommended_traits[:3]]
            
            # ì»¤ì„œ ë©”ë‰´ìš© ì˜µì…˜ êµ¬ì„±
            options = []
            descriptions = []
            
            for trait in available_traits:
                trait_name = trait.get('name', '')
                trait_desc = trait.get('description', '')
                
                # AI ì¶”ì²œ íŠ¹ì„±ì¸ì§€ í™•ì¸
                if trait_name in recommended_trait_names:
                    display_name = f"ğŸ¤–â­ {trait_name}"
                    description = f"[AI ì¶”ì²œ] {trait_desc}"
                else:
                    display_name = trait_name
                    description = trait_desc
                
                options.append({'text': display_name, 'detail': description})
                descriptions.append(description)
            
            # ê±´ë„ˆë›°ê¸° ì˜µì…˜ ì¶”ê°€
            options.append({'text': 'íŠ¹ì„± ì—†ì´ ê³„ì†', 'detail': 'íŠ¹ì„±ì„ ì„ íƒí•˜ì§€ ì•Šê³  ì§„í–‰í•©ë‹ˆë‹¤'})
            descriptions.append('íŠ¹ì„±ì„ ì„ íƒí•˜ì§€ ì•Šê³  ì§„í–‰í•©ë‹ˆë‹¤')
            
            # ì»¤ì„œ ë©”ë‰´ í‘œì‹œ
            menu = CursorMenu(
                title=f"{character.name}ì˜ íŠ¹ì„± ì„ íƒ (ğŸ¤– = AI ì¶”ì²œ)",
                options=options,
                descriptions=descriptions,
                screen_width=100,
                screen_height=30
            )
            
            choice = menu.display()
            
            if choice < len(available_traits):
                selected_trait = available_traits[choice]
                character.traits = [selected_trait]
                
                trait_name = selected_trait.get('name', '')
                if trait_name in recommended_trait_names:
                    print(f"\n{GREEN}âœ… AI ì¶”ì²œ íŠ¹ì„± '{trait_name}'ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤! ğŸ¤–â­{RESET}")
                else:
                    print(f"\n{GREEN}âœ… '{trait_name}' íŠ¹ì„±ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!{RESET}")
            else:
                print(f"\n{CYAN}íŠ¹ì„± ì„ íƒì„ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.{RESET}")
                    
        except Exception as e:
            print(f"{YELLOW}íŠ¹ì„± ì‹œìŠ¤í…œì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}{RESET}")
            print(f"{CYAN}íŠ¹ì„± ì—†ì´ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.{RESET}")

# ì „ì—­ ìë™ íŒŒí‹° ë¹Œë” ì¸ìŠ¤í„´ìŠ¤
auto_party_builder = AutoPartyBuilder()

def get_auto_party_builder() -> AutoPartyBuilder:
    """ìë™ íŒŒí‹° ë¹Œë” ë°˜í™˜"""
    return auto_party_builder
